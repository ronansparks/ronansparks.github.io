<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>整体性学习 - 《如何高效学习》</title>
      <link href="/2018/04/25/%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0-%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B/"/>
      <url>/2018/04/25/%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0-%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B/</url>
      <content type="html"><![CDATA[<p>为什么学了那么多年英语，还停留在“Hello”、“How are you?”阶段？</p><p>为什么在大学里，别人临时抱佛脚，还比你考的分高很多？</p><p>为什么读了那么多书，你却只记得个书名？</p><p>在很多人的眼里、数学是数学、生物是生物，两者是完全不同的学科，没有交集。如果说它们不只是孤城，而是可以相互连接成一个帝国，你会不会惊讶？</p><p>今天要介绍的<strong>整体性学习</strong>，就是为了刷新你的认知，高效地吸收学习，把你知道的商业、产品、设计、心理学、社会学、编程等孤立的知识，建成一个庞大的帝国，达到高效记忆和应用知识的目的。</p><p><strong>注意：</strong>这不是一蹴而就方法，需要你主动练习一段时间，形成习惯后；等潜意识自然而然地接手这套路，你就会变得轻松学习、灵活应用。</p><p>下方是我梳理的框架图，先有个大致了解，再阅读细节。</p><img src="/2018/04/25/整体性学习-《如何高效学习》/01_Learn.png"><h1 id="主要观点"><a href="#主要观点" class="headerlink" title="主要观点"></a>主要观点</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>信息就像大楼、大脑对知识的掌握程度，取决于你设计的结构（城市）能够盖多少信息（大楼）。</p><p>有的人数学很差，英语却很好；有的人英语很差，物理、化学却非常厉害。</p><p>你对喜欢的科目投入很多的时间，不断吸收信息，时常调整结构来容纳更多的信息；而其他科目，即使投入很多时间，也只是随便找了块地修些楼。没有好的结构，就像没有设计好的城市，到处是大楼，道路狭窄、经常塞车。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>建立模型，是为了压缩信息，即关键点。结构是由许多模型组成的。比如一座城市，有居民楼模型、商场模型、公园模型、车站模型。</p><h2 id="高速公路"><a href="#高速公路" class="headerlink" title="高速公路"></a>高速公路</h2><p>只有城市，还不能发挥大脑的作用（“你们对力量一无所知~”）。高速公路就是不同城市之间的联系，也就是不同结构之间的联系、不同学科之间的联系、不同领域之间的联系。由不同结构连接起来的整体，也是结构。</p><h1 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>获取就是指信息通过眼睛、耳朵进入大脑的过程。获取阶段的目标是信息要准确，然后压缩信息量。</p><p>3个主要目标：</p><ul><li>简化。比如“我是，我是，我是，我是，我是，我是”，可简化为<strong>“我是 x 6”</strong>。对于书籍、视频，直接跳过不重要的内容（比如引言，废话，感谢）。</li><li>容量。明白简化信息后，就该去获取更多的信息啦。（一年读几十本肯定比比读2、3本要知道的多。）</li><li>速度。时间是有限的，效率很重要。（这需要好的阅读和听讲方法，稍后会介绍。）</li></ul><p><strong>反问测试法：</strong>我以前看过/听过这个知识吗？</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>理解就是了解信息的基本意思，并放在上下文中进行联系。</p><p>只获取而不理解，是填鸭式的学习。（比如学习冒泡排序的时候，是一步一步引导你去理解、掌握的，而不是让你把代码段背下来。）</p><p><strong>反问测试法：</strong>我理解了这个知识的含义（字面/深层）吗？</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>（重点）这一步就是打造模型、建立高速公路、构建良好的结构。</p><p>3种主要方式：</p><ul><li>深度拓展 - 溯源。缺点是要花更多的时间。</li><li>横向拓展 - 联系。建立模型，在模型与相同领域里已学的知识之间建立联系。（比如学世界历史的时候，联想到已学的中国历史，你就知道别人在忙着工业革命的时候，乾隆也忙着带领中国由盛转衰呢。）</li><li>（重点）纵向拓展 - 学习迁移。知识都遵循一定模式，同样的模式，也可能应用到其他领域中。（比如学会了数学有利于学习物理；学会了英语有利于学习西班牙语。）</li></ul><p><strong>反问测试法：</strong>我知道这个知识产生的背景，以及和已有的知识有联系吗？</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>学以致用，将知识应用到生活中，解决问题。</p><p><strong>反问测试法：</strong>我把这知识用起来了吗？</p><h2 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h2><p>实际应用后，对知识做微调。（如添加特殊情况、删除知识间与现实不符的联系。）</p><p><strong>反问测试法：</strong>修正了过去形成的错误模型吗？删除了错误的结论吗？</p><p><strong>小结：不一定要按这个顺序，这里是为了有规律可循，便于掌握。后期可以自由决定按照什么步骤进行学习。</strong></p><h1 id="信息类型"><a href="#信息类型" class="headerlink" title="信息类型"></a>信息类型</h1><p>对于不同的领域、学科、知识，虽然学习的过程类似，但是知识的结构是不同的。</p><h2 id="随意信息"><a href="#随意信息" class="headerlink" title="随意信息"></a>随意信息</h2><p>是一系列事实、日期、定义、规则、公式；缺少逻辑分类；需要死记硬背。（比如各种历史事件、二十四节气。）</p><h2 id="观点信息"><a href="#观点信息" class="headerlink" title="观点信息"></a>观点信息</h2><p>是存在争论的信息。（比如最好的语言是Java还是Swift？）</p><h2 id="过程信息"><a href="#过程信息" class="headerlink" title="过程信息"></a>过程信息</h2><p>是教导你怎么行动的信息。（比如学游泳、学写第一个”Hello World!、学做番茄牛腩。）</p><h2 id="具体信息"><a href="#具体信息" class="headerlink" title="具体信息"></a>具体信息</h2><p>是在实际中可以看到、听到、触摸到的信息。（比如大象比狗大、冰雪会融化）</p><h2 id="抽象信息"><a href="#抽象信息" class="headerlink" title="抽象信息"></a>抽象信息</h2><p>是与人的感官没有直接联系的信息。（比如数学、微积分、心理学、编程）</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="获取知识"><a href="#获取知识" class="headerlink" title="获取知识"></a>获取知识</h2><h3 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h3><p>解决容易分心问题、一段文字要读好几遍的问题、读的太慢的问题、笔记记太多/记太少，也还是不懂的问题</p><ul><li><p>指读法：用手指指着要阅读的地方，可以提高阅读速度，不容易分心。</p></li><li><p>练习阅读法：不同于一般阅读。目的不是吸收阅读的内容，是为了训练自己以尽可能快的速度理解所读的内容。</p><p>阅读速度练习：</p><p>1.拿本没读的书，标记准备读的地方，设定3分钟，用指读法，以稍快于自己能读懂内容的速度进行阅读。</p><p>2.计算 <strong>读的行数 x 每行平均字数 / 3</strong> 。能测出你提高阅读速度后，能达到的程度。</p><p>​</p><p>理解力练习：</p><p>1.读3分钟材料，凭记忆写下你记住的知识点。</p><p>2.再读一遍材料，边读边记下知识点。</p><p>3.比较两份记录，统计下凭记忆写下的，正确的、错误和漏写的有多少？</p><p>4.<strong>正确的 - （错误的、漏写的）/ 所有的知识点数</strong>。能测出你以一定阅读速度阅读这类型材料的理解能力。</p><p>​</p><p>通过降低阅读速度，可以提高理解能力，达到最快的阅读速度 + 最好的理解能力。</p></li><li><p>积极阅读法（用于专业性的书籍）：强调深入理解材料。1.这一节主要观点？；2.怎样才能记住它？；3.怎样才能拓展它、应用它？</p></li></ul><p>快速阅读是一项技能，需要反复练习。</p><p><strong>挑战：</strong></p><ol><li>买一两本内容适合做快速阅读练习的书。</li><li>3周内，每天15分钟进行阅读速度和理解力的练习（见前面“练习阅读法”）。</li><li>练习2周指读法。</li><li>每周练习1次积极阅读法。</li></ol><h3 id="笔记流"><a href="#笔记流" class="headerlink" title="笔记流"></a>笔记流</h3><p>遵循“一次学会”的原则，不要想着记完笔记，以后再学，更多的时候你不会再想起去看笔记。</p><ol><li>只记主要观点，用词语、短句概括。</li><li>在观点间画箭头，划线、画圈建立联系。</li></ol><p>（这有个学生挑战，有需要的可以去书上可以找。）</p><h2 id="理解和拓展"><a href="#理解和拓展" class="headerlink" title="理解和拓展"></a>理解和拓展</h2><h3 id="比喻法"><a href="#比喻法" class="headerlink" title="比喻法"></a>比喻法</h3><p>比喻是一种文学的用法，用来将某个物体与其他物体联系起来。（比如跟你说大众有款甲壳虫车，即使你没见过，也猜到什么样子了。）</p><p>（这有个学生挑战，有需要的可以去书上可以找。）</p><h3 id="内在化"><a href="#内在化" class="headerlink" title="内在化"></a>内在化</h3><p>指不仅仅在脑海中出现画面，还有声音、触觉、情感等。</p><ol><li>明确要内在化的概念。（是编程函数，还是数学概念？）</li><li>在脑海中绘制图像。（不习惯的话，可以在纸上画草图。）</li><li>静态图还是动态图？</li><li>加上其他感官。（用手摸它、嗅它、听它，赋予情感。）</li></ol><p><strong>挑战：</strong></p><ol><li>准备纸、笔。</li><li>从书中找2个概念或观点。</li><li>在脑海中绘制图像，加入感官知觉、情感。</li><li>根据脑海中的图像，在1分钟内画出来。</li><li>坚持两周，每天练几个。</li></ol><h3 id="图表法"><a href="#图表法" class="headerlink" title="图表法"></a>图表法</h3><p>是内在化的简化。</p><p>三种主要图表类型：</p><ul><li>流程图：绘制一系列的步骤；绘制历史事件；绘制一个系统（函数的执行过程）。</li><li>概念图：写出观点，在观点间画箭头并在箭头上加描述；从主角开始，描绘红楼梦里的角色关系；</li><li>图像：涂鸦代替前两个图中的文字和联系，更生动，容易记。</li></ul><p><strong>挑战：</strong></p><ol><li>找一个观点/概念。</li><li>设定2-5分钟，上面图表形式三选一，开始画。</li><li>时间到了后，统计工作量。（包括有多少信息、建立了多少联系）</li><li>每天1次，重复2周。</li></ol><h3 id="处理随意信息"><a href="#处理随意信息" class="headerlink" title="处理随意信息"></a>处理随意信息</h3><p>联想法：将一系列观点串在一起，按顺序排列，形成链条。记住任意一环，都能寻找到其他环节。（比如班上同学排成一列，不要记住每个人的顺序，只需要每个人记住自己前后是谁。）</p><p>挂钩法：类似于联想法，没有顺序，你能回忆起单个信息。（比如看图记单词/小学字母表，“e”的旁边还画了一只鹅。就算忘了字母顺序了，看到鹅还能记起“e”这个字母来。）</p><p>信息压缩法：目标是减少信息的容量。归类，建立逻辑联系。（比如急救术中的术语RED，R、E、D又分别代表3个单词。记得时候记住RED，用的时候再还原。类似于旅行前把衣服真空压缩，要穿的时候再还原。）</p><h2 id="纠错和应用"><a href="#纠错和应用" class="headerlink" title="纠错和应用"></a>纠错和应用</h2><p>实际应用：将知识应用于实际，会记得更牢。（比如用统计学解决生活中的问题；用编程中学的算法，在黄页书中快速找到某人；读历史，以史为镜。）</p><p>模型纠错：在实践中发现问题，快速修正。就像代码需要运行后，才发现错误。</p><p>以项目为基础的学习：设定1-3个月的目标，过程即学习！记录进度！</p><h1 id="如何超越"><a href="#如何超越" class="headerlink" title="如何超越"></a>如何超越</h1><h2 id="高效率"><a href="#高效率" class="headerlink" title="高效率"></a>高效率</h2><ol><li>能量管理：不要把日程安排满满的；设定90分钟，集中注意力完成任务；每周运动几次；至少7、8个小时睡眠；健康的饮食，少吃多餐；多喝水；一周至少休息一天；晚上做点轻松的。</li><li>聪明学习：获取 - 理解 - 拓展 - 应用 - 纠错。学十几个小时，未必能考高分/学到很多东西。</li><li>不拖延：把某个任务定在一个时间点，一次性完成；每天检查当日任务清单。</li><li>批处理：将类似的工作放在一起处理。（如一次性接收邮件/微信，不要随时盯着邮件/微信，减少分心频率。）</li><li>有组织：物品放在固定位置；使用记事本/App，随时记录；使用日历和清单，设定任务和截止日期。</li></ol><h2 id="自我教育"><a href="#自我教育" class="headerlink" title="自我教育"></a>自我教育</h2><ol><li>好习惯：每日阅读，一年50本以上；每日练习；每日目标。先坚持30天习惯！继续坚持！享受习惯！</li><li>克服障碍：写下障碍，使用网络，书籍，视频解决障碍。</li><li>设定目标：每年阅读书籍数量；为项目工作，过程即学习；在某截止日期前，学会某件事。（设定目标的技巧：写下目标！有判断标准的目标！设定努把力可以达到的截止日期！目标具体化到每周、每天！经常查看目标进度！）</li></ol>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS动画之UIView动画</title>
      <link href="/2018/04/24/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BUIView%E5%8A%A8%E7%94%BB/"/>
      <url>/2018/04/24/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BUIView%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p><strong>前言</strong></p><p>对于一个App，能完成基本功能，只能算及格。优秀的交互、视觉能够提升用户体验，够得上优秀。再加上细节、打动人心的动画，就更完美了。</p><h1 id="内容动画"><a href="#内容动画" class="headerlink" title="内容动画"></a>内容动画</h1><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>通过改变视图（UIView）的属性值来创建动画。</p><p>可以设置的属性有：</p><ol><li>中心坐标（center）</li><li>大小（bounds）</li><li>大小及原点坐标（frame）</li><li>变换（transform）</li><li>透明度（alpha）</li><li>背景色（backgroundColor）</li><li>内容拉伸（contentStretch）</li></ol><p>iOS 4 之后，苹果推荐使用Block动画方法。（iOS 4 之前有种手动开始、结束动画的方法。也就没必要介绍了。）</p><p>使用以下3种Block动画</p><ol><li>普通动画。设置动画时长、动画效果</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval) {    //动画        }</code></pre><ol start="2"><li>延时动画。设置动画时长、动画效果、动画完成回调</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, animations: {    //动画}) { finishFlag in    //动画完成回调        }</code></pre><ol start="3"><li>过渡效果动画。设置动画时长、延迟时间、过渡效果、动画效果、动画完成回调</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, delay: TimeInterval, options: UIViewAnimationOptions, animations: {    //动画        }) { finishFlag in    //动画完成回调        }</code></pre><p>UIViewAnimationOptions结构体参数</p><pre><code class="swift">public static var layoutSubviews: UIViewAnimationOptions { get } //动画过程时，布局子控件public static var allowUserInteraction: UIViewAnimationOptions { get } // 动画过程中，允许用户交互public static var beginFromCurrentState: UIViewAnimationOptions { get } // 从当前状态开始动画public static var `repeat`: UIViewAnimationOptions { get } // 无限循环动画public static var autoreverse: UIViewAnimationOptions { get } // 如果循环动画，往返两个方向进行public static var overrideInheritedDuration: UIViewAnimationOptions { get } // 忽略方法里动画时长public static var overrideInheritedCurve: UIViewAnimationOptions { get } // 忽略方法里的曲线设置public static var allowAnimatedContent: UIViewAnimationOptions { get } // 转场： 动画过程中，重绘视图public static var showHideTransitionViews: UIViewAnimationOptions { get } // 专场： 翻转到隐藏状态，或者从隐藏状态翻转到显示出来。public static var overrideInheritedOptions: UIViewAnimationOptions { get } // 不继承父动画的设置public static var curveEaseInOut: UIViewAnimationOptions { get } // 时间曲线，慢进慢出(默认)public static var curveEaseIn: UIViewAnimationOptions { get } // 时间曲线，慢进public static var curveEaseOut: UIViewAnimationOptions { get } // 时间曲线，慢出public static var curveLinear: UIViewAnimationOptions { get } // 时间曲线，匀速进出public static var transitionFlipFromLeft: UIViewAnimationOptions { get } //转场： 从左向右翻页public static var transitionFlipFromRight: UIViewAnimationOptions { get } //转场： 从右向左翻页public static var transitionCurlUp: UIViewAnimationOptions { get } //转场： 从下向上卷曲翻页public static var transitionCurlDown: UIViewAnimationOptions { get } //转场： 从上向下卷曲翻页public static var transitionCrossDissolve: UIViewAnimationOptions { get } //转场： 交叉消失和出现public static var transitionFlipFromTop: UIViewAnimationOptions { get } //转场： 从上向下翻页public static var transitionFlipFromBottom: UIViewAnimationOptions { get } //转场： 从下向上翻页public static var preferredFramesPerSecond60: UIViewAnimationOptions { get } //转场： 帧率60public static var preferredFramesPerSecond30: UIViewAnimationOptions { get } //转场： 帧率30</code></pre><ol start="4"><li>弹性动画</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, delay: TimeInterval, usingSpringWithDamping: CGFloat, initialSpringVelocity: CGFloat, options: UIViewAnimationOptions, animations: {    //动画}) { finishFlag in    //动画完成回调}</code></pre><ol start="5"><li>帧动画</li></ol><pre><code class="swift">UIView.animateKeyframes(withDuration: TimeInterval, delay: TimeInterval, options: UIViewKeyframeAnimationOptions, animations: {    //动画        }) { finishFlag in    //动画完成回调        }</code></pre><p>UIViewKeyframeAnimationOptions结构体</p><pre><code class="swift">public static var layoutSubviews: UIViewKeyframeAnimationOptions { get }public static var allowUserInteraction: UIViewKeyframeAnimationOptions { get } // 动画过程中，允许用户交互public static var beginFromCurrentState: UIViewKeyframeAnimationOptions { get } // 从当前状态开始动画public static var `repeat`: UIViewKeyframeAnimationOptions { get } // 无限循环动画public static var autoreverse: UIViewKeyframeAnimationOptions { get } // 如果循环动画，往返两个方向进行public static var overrideInheritedDuration: UIViewKeyframeAnimationOptions { get } // 忽略方法里动画时长public static var overrideInheritedOptions: UIViewKeyframeAnimationOptions { get } // 不继承父动画的设置public static var calculationModeLinear: UIViewKeyframeAnimationOptions { get } // 运算模式： 连续public static var calculationModeDiscrete: UIViewKeyframeAnimationOptions { get } // 运算模式： 离散public static var calculationModePaced: UIViewKeyframeAnimationOptions { get } // 运算模式： 均匀public static var calculationModeCubic: UIViewKeyframeAnimationOptions { get } // 运算模式： 平滑public static var calculationModeCubicPaced: UIViewKeyframeAnimationOptions { get } // 运算模式： 平滑均匀</code></pre><h2 id="视图控制器动画"><a href="#视图控制器动画" class="headerlink" title="视图控制器动画"></a>视图控制器动画</h2><p>自定义视图控制器（UIViewController）的转场动画。</p><h1 id="物理动画"><a href="#物理动画" class="headerlink" title="物理动画"></a>物理动画</h1><h2 id="UIKit动态"><a href="#UIKit动态" class="headerlink" title="UIKit动态"></a>UIKit动态</h2><p>给UIView应用真实世界的物理效果。</p><h1 id="视差效果"><a href="#视差效果" class="headerlink" title="视差效果"></a>视差效果</h1><h2 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h2><p>给UIView添加微妙的效果，来展现3D效果</p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> animation </tag>
            
            <tag> uiview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>23种设计模式的Swift实现</title>
      <link href="/2018/04/21/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/21/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p><strong>前言：</strong></p><p>在介绍设计模式（Design Pattern）之前，先声明几点，以免大家误入歧途。</p><p>对于设计模式的作用，一直很有争议。有人奉为圭臬，有人嗤之以鼻，他们的认知都错了吗？不是的，他们都受了“知识的诅咒”。</p><p>“知识的诅咒”是说，在你学会一个方法前，觉得好像有点难；而在你学会之后，很难想象不会这个方法是种什么样的体验。比如你学会了修电脑之后，觉得挺简单的，就纳闷“怎么会有人不懂修电脑？”（5分钟就搞定，那我就不留下来过夜了…）。</p><p>新手刚学习了设计模式，但是还没有完全理解，急于应用在代码中，就会出现生搬硬套，过度设计的状况。</p><p>而嗤之以鼻的人觉得没有自己学习设计模式，也写过了很多“单例模式”、“观察者模式”，这是属于一种探索的模式，以实践代替理论，这可能导致疏忽，写来写去也就会那几种模式，遇到问题时，需要花费数倍的时间来探索。</p><p>而学了设计模式的人，并知道设计模式的出现是为了解决什么问题，他们并不会随时想着使用设计模式，而是在需要的时候，灵活应用。</p><p>设计模式，只是一种对经验的总结。因为这些解决问题的方法，被反复使用，是开发者试错、验证总结出来的。所以对它们进行整理分类，给更多的人看到，避免采坑，避免重复造轮子（每个人都根据经验自己总结一遍）。</p><p>设计模式的目的，为了代码的可重用性、可靠性，便于与其他开发者的沟通。</p><img src="/2018/04/21/23种设计模式的Swift实现/01_23种设计模式.png"><p><em>环境： Swift 4.1  Xcode 9.3</em></p><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><p>提供了一种在创建实例的同时，隐藏创建逻辑的方式。灵活选择要创建的实例。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在App整个生命周期里，保证一个类只初始化一次，并提供一个类型方法可以访问这个实例。</p><p><em>如系统UIApplication的sharedApplication</em></p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>通过拷贝已有实例，来创建新的实例。</p><p><em>当已创建的实例复杂且耗时，或者新实例属性值与已有实例的属性值有很多重叠</em></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义一个基类/协议，多个子类继承它，创建一个工厂类型，根据传入的参数来创建对应的子类。这样就对外界隐藏子类创建逻辑。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>围绕一个超级工厂，创建其他工厂。</p><p><em>比如Circle，Rect继承自抽象的Shape类型，创建一个工厂类型ShapeFactory来根据传入的参数来创建对应的子类；Red，Blue继承自抽象的Color类型，创建一个工厂类型ColorFactory来根据传入的参数来创建对应的子类；超级工厂来根据传入的参数，来创建对应的工厂类型。</em></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><p>关注类和实例的组合。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><p>关注实例之间的通信。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="访问器模式"><a href="#访问器模式" class="headerlink" title="访问器模式"></a>访问器模式</h2><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> design pattern </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品需求 - 从理解到实施</title>
      <link href="/2018/04/19/%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82-%E4%BB%8E%E7%90%86%E8%A7%A3%E5%88%B0%E5%AE%9E%E6%96%BD/"/>
      <url>/2018/04/19/%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82-%E4%BB%8E%E7%90%86%E8%A7%A3%E5%88%B0%E5%AE%9E%E6%96%BD/</url>
      <content type="html"><![CDATA[<p>在产品开发过程中，最先要考虑的就是需求，和各部门沟通的也是需求。需求是产品构建的基石，需求制定偏了，整个产品方向也就会偏离预期。</p><p>需求是什么？可以总结为几类？如何收集、筛选、实现需求。</p><p>先放上框架图，本文目的是初探需求。</p><img src="/2018/04/19/产品需求-从理解到实施/01_Structure.png"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>需求是指人在某个场景下的心理活动。（用户 - 场景  - 心理）</p><p>小明，饿了，想要吃饭。这就是需求。</p><p>所以说，需求是来源于用户的，出发点是要解决用户遇到的问题。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>优先级：</p><ul><li>必要需求：为直接解决问题，必须要做的事。</li><li>次要需求：做了会提升用户满意度，不做也不影响。</li></ul><p>小明很饿，你给了他一碗面，他能饱腹；如果给他牛肉面，他能心满意足（碰巧他很喜欢吃牛肉）。</p><p>频次：</p><ul><li>高频需求：日常生活中，频繁经历的场景。</li><li>低频需求：日常生活中，发生次数较低的场景。</li></ul><p>听音频，随时随地，这就是高频需求；充话费，一月一两次，这是低频需求。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>美国心理学家马斯洛，在上个世纪提出了<em>需求层次理论</em>，把需求分为5层，呈金字塔形状。</p><ol><li>生理需求：衣食住行，性冲动。</li><li>安全需求：人身、财产，所有权。</li><li>社交需求：亲情、友情、爱情。</li><li>尊重需求：自信、自尊、受人尊敬。</li><li>自我实现：道德、理想、愿景、成就。</li></ol><p>这个分层是说人对这些需求的依赖性，生理需求是最基本的。分层并不代表社会各阶层，任何阶层都可以有各层需求。所有的需求都可以归为这里某一层。</p><h1 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h1><ul><li>问卷调查：向潜在目标用户，发放问卷进行数据采集。（问卷调查设计，是个技术活，值得花时间学习）</li><li>热爱生活：观察环境，你会发现走过无数次的路，其实你并不熟悉。观察人们行为，从生活中发现灵感。</li><li>模拟用户：分析用户行为，代入用户角色，去体验产品，发现问题。</li><li>用户反馈：如果收到用户反馈，哪怕是自动回复下感谢，您也吱一声啊，用户才继续忍受你的bug，给你反馈。</li><li>用户访谈：和用户交流，重视用户意见，让用户有种参与感，用户和产品的联系增加，甚至自发宣传。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>深入挖掘：要认真分析从用户处收集的需求，不要只看到表面现象，深入分析用户真正的需求。</li><li>核心需求：给需求排序，按照28法则，把时间主要花在核心需求上，就能解决80%的问题。</li><li>老板需求：在创业公司，老板会时不时提出加点需求，这时需要沟通、分析老板的需求是否是表层的，然后分析给出真实需求。有些PM直接把老板需求加入需求实现里面，自己成了一个传声筒而已。</li><li>跟进需求：在制定需求之后，需要跟进需求实现的每一环，防止因理解偏差而导致结果偏离。</li></ul>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需求 </tag>
            
            <tag> 马斯洛 </tag>
            
            <tag> 需求层次 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何打造流行 - 《引爆点》</title>
      <link href="/2018/04/15/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E6%B5%81%E8%A1%8C-%E3%80%8A%E5%BC%95%E7%88%86%E7%82%B9%E3%80%8B/"/>
      <url>/2018/04/15/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E6%B5%81%E8%A1%8C-%E3%80%8A%E5%BC%95%E7%88%86%E7%82%B9%E3%80%8B/</url>
      <content type="html"><![CDATA[<p>2011年之前，两个朋友网上聊天前，都是A先发送两个字 - “在吗”，有时A还喜欢加个问号”？”，B也要回复“嗯/在/在的”这几个备选词，然后开始瞎扯。大家仿佛都遵从了TCP协议一样。</p><p>这一天，你在某软件上收到一条语音，打破了整个世界的平静。楼道里、教室里、大街上，对着手机自言自语的人开始多了起来，声音此起彼伏。打望了一圈，人们看上去好像和平时一样，只是惊讶姿势如此统一，手机在手上，手在嘴边。聊天不再TCP式，假设对方永久在线，直接切入主题。微信就这样入侵了人们的世界，个个不能自已，上瘾一样。</p><p>无人问津到炙手可热，有时可能只是中间差那么一点，引爆点。</p><p>流行的特征：</p><ul><li>传染性：像流感一样，无法抗拒。</li><li>蝴蝶效应：细节可能导致失败，或者成功。</li><li>爆发式：一夜之间，家喻户晓、洛阳纸贵。</li></ul><img src="/2018/04/15/如何打造流行-《引爆点》/01_Structure.png"><h1 id="三个法则"><a href="#三个法则" class="headerlink" title="三个法则"></a>三个法则</h1><h2 id="个别人物法则"><a href="#个别人物法则" class="headerlink" title="个别人物法则"></a>个别人物法则</h2><h3 id="联系员"><a href="#联系员" class="headerlink" title="联系员"></a>联系员</h3><p>有个关于人与人之间关系的理论，叫做六度人脉理论（Six Degrees of Separation），也叫六步分离法则。它指的事地球上所有人都可以通过六层熟人关系和其他人联系起来。比如说你可以通过你最有影响力的朋友（政府官员、红人、高管），再通过他的人脉，总共不超过6次传递，就可以把你的笑话讲给特朗普听。</p><p>这里谈到的你最有影响力的朋友，就是属于联系员，这类人可以把消息最快地传播出去。如现在的网红，都是特定领域的联系员</p><h3 id="内行"><a href="#内行" class="headerlink" title="内行"></a>内行</h3><p>这类人一般在他工作的行业，或者爱好的领域，投入了足够多的时间，去尝试新事物，去研究，乐于分享。在他的圈子都很受欢迎，说话有分量。</p><p>所以我们倾向于向吃货朋友询问附近的美食，向美剧控朋友寻求资源，请程序员朋友修电脑（别打我）。</p><h3 id="推销员"><a href="#推销员" class="headerlink" title="推销员"></a>推销员</h3><p>这类人喜欢与人打交道，精力充沛，能够看透客户的心理，更容易说服别人。可以把死的说成活的，你还配合地连连点头称是。</p><h3 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h3><p>联系员靠广撒网多捞鱼，比如推荐附近一家饭店给10个朋友，可能就有5个会去；内行靠权威性，比如给5个朋友推荐餐馆，可能这5个人都会去；推销员靠心理学 + 嘴皮子，知道你喜欢这口味，给个优惠券，你就屁颠屁颠地跑去这家餐馆了。</p><h2 id="附着力因素法则"><a href="#附着力因素法则" class="headerlink" title="附着力因素法则"></a>附着力因素法则</h2><h3 id="打磨产品"><a href="#打磨产品" class="headerlink" title="打磨产品"></a>打磨产品</h3><p>一款产品，用尽手段，即使拉到了用户，短期内实现了增长。但如果产品本身不够好，没有用户黏性，具有欺骗性质的。要不了多久，还是会趋近于其本身所应处的位置。</p><h3 id="扫除障碍"><a href="#扫除障碍" class="headerlink" title="扫除障碍"></a>扫除障碍</h3><p>为什么国外大公司进入中国，大都会水土不服？或许他们认为Too good for us，不屑针对本地化进行定制；或许不懂国情和文化。针对目标用户设计，倾听用户意见，这些措施能够减少用户的负担，使得用户易于使用产品。</p><h2 id="环境威力法则"><a href="#环境威力法则" class="headerlink" title="环境威力法则"></a>环境威力法则</h2><h3 id="破窗理论"><a href="#破窗理论" class="headerlink" title="破窗理论"></a>破窗理论</h3><p>如果一栋房屋有几扇窗户被打破了，没有修理，慢慢地有会有更多窗户被打破。类似的有，音乐节上，嘈杂的人群，一个人开始没有带走垃圾，不久到处都是垃圾；如某xxBeta新闻网站，一个人开始评论脏话，无脑喷子，管理员不清理，慢慢的整个网站评论下都是喷子。</p><p>尤其产品初期，通过紧盯反馈，评论，及时解决用户问题，疏导用户情绪；企业遇到公关危机，及时PR，不然越来越多吃瓜群众也开始跟着抨击。</p><h3 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h3><p>人们总爱犯的一种错误是，高估性格因素，低估具体情形和环境因素。</p><p>近朱者赤近墨者黑。要理解环境的重要性，营造良好的环境、基调、氛围，针对具体情形迅速拿出可行的方案。</p><h3 id="群体力量"><a href="#群体力量" class="headerlink" title="群体力量"></a>群体力量</h3><p>任何新兴意识形态的传播都要借助于群体力量。为了长期发展，增加用户黏性，必须建立社区或组织，这样人们可以交流，互相影响，提高忠诚度，产生1 + 1 &gt; 2的效果。</p><h1 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h1><h3 id="单点突破"><a href="#单点突破" class="headerlink" title="单点突破"></a>单点突破</h3><p>尤其是企业，产品初期，可用的资源有限，无法覆盖全面，把有限的资源集中用到关键方面。也就是现在常说的单点突破</p><h3 id="传真机效应"><a href="#传真机效应" class="headerlink" title="传真机效应"></a>传真机效应</h3><p>也叫充裕定律，加入网络的个体越多，网络的价值越高。</p><p>第一台传真机零售价2000美元，如果世界仅此一台，它是毫无价值的。第二台传真机，使得第一台有了价值。第三台传真机使得彼此更有价值。比如我们更多是用微信，而很少用FB，或其他私密社交，因为我们的熟人都在这里，别的软件就没那么多价值。</p><h3 id="内行陷阱"><a href="#内行陷阱" class="headerlink" title="内行陷阱"></a>内行陷阱</h3><p>这不是个贬义词，是说如何找到内行人士。</p><p>做产品，要留下反馈渠道，只有内行才会花费时间去反馈，换做一般人，用着不合适直接不用，根本不会考虑告诉你哪里有问题。因此反馈渠道不能太深，而且收到反馈后，应予以回应，至少一条自动回复的感谢消息，也会鼓励内行人士继续使用并反馈。</p>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引爆点 </tag>
            
            <tag> 传播 </tag>
            
            <tag> 心理学 </tag>
            
            <tag> 产品 </tag>
            
            <tag> 商业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程的介绍与演示</title>
      <link href="/2018/04/13/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%BC%94%E7%A4%BA/"/>
      <url>/2018/04/13/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%BC%94%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>本篇文章会简单介绍线程的概念，以及如何区分。接着开始讲解iOS开发中提到的4种方式，不要紧张，最常用的就2种。最后稍微带过下线程安全方面的知识。</p><p>先放出本次内容的框架图，以便有条理的阅读和掌握。</p><div align="center"><br><br><img src="/2018/04/13/iOS多线程的介绍与演示/01_Thread.png"><br><br></div><p><em>环境： Swift 4.1  Xcode 9.3</em></p><p><em>可下载工程项目，进行把玩，更直观地了解。</em> <a href="https://github.com/ronansparks/ThreadForiOS-Demo" target="_blank" rel="noopener">Github</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>程序/App：</strong>只是存储数据和文件的文件夹。如一辆Tesla。</p><p><strong>进程：</strong>启动App，才开始有了进程。把车启动了，才能跑起来。</p><p><strong>线程：</strong>一个进程里可以有很多线程，把资源和任务交给它们去执行。车轮跑起来，开冷气，显示屏，都是交给很多的零件负责执行。</p><h2 id="细说线程"><a href="#细说线程" class="headerlink" title="细说线程"></a>细说线程</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>在iOS里，处理UI的线程就是主线程，在App启动时由系统自动创建。不要把耗时的操作放在主线程里，会造成页面的卡顿、不响应、崩溃。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>理论上同一时刻，一个CPU只能处理一条线程。但是线程间切换极快，你感觉在同时听歌、聊微信、下载歌曲。使用多线程就是为了提高效率，最大化利用资源，节省时间。</p><h3 id="线程周期"><a href="#线程周期" class="headerlink" title="线程周期"></a>线程周期</h3><p>线程生命周期，如下图所示</p><div align="center"><br><br><img src="/2018/04/13/iOS多线程的介绍与演示/02_Thread_LifeCycle.jpg"><br><br></div><p>新建：实例化线程对象。</p><p>待运行：线程实例对象调用start方法，被加入可调度线程池，等待CPU调度。</p><p>运行中：CPU调度该线程实例对象。在完成任务前，CPU可能跑去调度别的线程，使该线程在<strong>待运行</strong>和<strong>运行中</strong>状态间切换。</p><p>阻塞：阻塞该线程执行任何操作。可以手动设置休眠、设置锁、移除可调度线程池。</p><p>结束：完成任务，正常结束周期；未完成任务前，被终止。</p><h1 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h1><h2 id="四种方案"><a href="#四种方案" class="headerlink" title="四种方案"></a>四种方案</h2><h3 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h3><p><strong>POSIX</strong>（POSIX threads），一套可在Unix/Linux/Mac等系统通用的多线程API。要手动管理生命周期，太繁琐。</p><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>由Apple提供的，更面向对象，易操作的线程对象。也需要手动管理生命周期。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>全称为Grand Centeral Dispatch，由Apple推出，用以替代NSThread，更高效地利用多核。自动管理生命周期。</p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>Apple把GCD封装了一层，操作更简便，更符合面向对象。自动管理生命周期。</p><p>我们几乎不怎么使用Pthread，很少使用NSThread。常用的就是GCD和NSOperation</p><h2 id="细说GCD"><a href="#细说GCD" class="headerlink" title="细说GCD"></a>细说GCD</h2><p>要细说GCD，先引入几个概念。</p><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p>同步（sync）和异步（async）指的是能否开启新线程。</p><p>同步：多个任务情况下（如A、B、C），任务A执行结束，才执行B，B执行结束，才执行C。仅一个线程。</p><p>异步：也就是多线程的意思。开启新线程，多个任务可以同时执行。</p><pre><code>//在全局并发队列，同步执行 - 单线程DispatchQueue.global().sync {}//在全局并发队列，异步执行 - 多线程DispatchQueue.global().async {}</code></pre><h3 id="串行、并发"><a href="#串行、并发" class="headerlink" title="串行、并发"></a>串行、并发</h3><p>串行队列（Serial）和并发队列（Concurrent）指的是任务的执行方式。</p><p>串行队列：多个线程时，各个线程按顺序执行，执行完一个线程，才能进入下一个线程。</p><p>并发队列：多个线程可以同时执行。</p><p>手动创建队列的方法</p><pre><code class="swift">//串行队列let serialQueue = DispatchQueue(label: &quot;com.ronansparks.serial&quot;)//并发队列let concurrentQueue = DispatchQueue(label: &quot;com.ronansparks.concurrent&quot;, attributes: .concurrent)</code></pre><p>获取GCD全局队列的方法</p><pre><code class="swift">//获取GCD全局并发队列，优先级为默认级别DispatchQueue.global().async {    //耗时任务放这里执行    //获取GCD主队列    DispatchQueue.main.async {    //回主线程，操作UI    }}</code></pre><ul><li>同步不会开启新线程，只能按顺序执行；</li><li>串行队列，规定只能顺序执行；（主队列也是串行）</li><li>主队列使用同步，会发生死锁，导致程序崩溃。</li><li>只有并发队列使用异步，才能高效利用资源。开启新线程，同时执行多个任务。</li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>在前面获取GCD全局队列的方法里，就是异步线程中耗时操作结束，回到主线程操作UI</p><p>在多个异步并发队列间，插入栅栏，在栅栏位置之后的异步队列需要等前面的所有任务执行完，才开始执行</p><pre><code class="swift">  concurrentQueue.async(flags: .barrier) {      //我是一个路障，后面的乖乖等着前面的吧  }</code></pre><p>延时执行</p><pre><code class="swift">  DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + 3) {      //3s 后要执行的任务  }</code></pre><p>队列组。把多线程都丢到一个组里，坐等所有都执行完之后的通知。</p><h2 id="细说NSOperation"><a href="#细说NSOperation" class="headerlink" title="细说NSOperation"></a>细说NSOperation</h2><p>NSOperation是对GCD的封装，需要配合NSOperationQueue才能实现多线程。只需要三步</p><ol><li>创建任务（NSOperation）</li><li>创建队列（NSOperationQueue）</li><li>把任务添加到队列</li></ol><p>NSOperation是个抽象类，我们使用它的子类NSBlockOperation（用Objective-C还有子类NSInvocationOperation，因为不是类型安全，所以在Swift里被禁用了），或者自定义子类。</p><ul><li>不添加到队列，需要手动调用start方法，默认在主线程执行。</li><li>Operation添加到队列后，自动执行。</li><li>实例可以通过添加执行代码块的方式，实现主线程。<strong>addExecutionBlock { code }</strong></li></ul><p>NSOperationQueue有主队列、和其他队列（串行、并发）。</p><ul><li>可以不需要单独创建Operation，通过队列代码块实现异步。</li><li>同GCD，在耗时操作执行后，切回主线程操作UI。通过<strong>OperationQueue.main</strong>访问主线程队列，把UI操作加入到该队列</li><li>可以设置最大并发数。设置为1，即顺序执行。</li><li>可以取消、暂停某个操作或整个队列里的操作。</li><li>可以设置依赖，即B必须在A完成之后才能执行。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多个线程访问一个资源的时候，容易导致数据错乱、数据安全问题。</p><p>互斥锁（同步锁）：第一个线程访问的时候，加个锁，表示它在使用；后来的都无法访问，进入休眠。</p><p>自旋锁：当新线程访问时，发现对象已被锁定，它会一直等待，不停尝试访问，耗性能。</p>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS个人开发者账号申请</title>
      <link href="/2018/04/11/iOS%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7/"/>
      <url>/2018/04/11/iOS%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7/</url>
      <content type="html"><![CDATA[<p>今天来手把手讲解一下，申请iOS个人开发者账号的流程。一个从旁观者，到参与者的转变。</p><p>有两个必备条件：</p><ul><li>一个Apple ID</li><li>一张Visa / Master的国际信用卡</li></ul><p>对于Apple ID，如果你有一部iPhone/iPad/Macbook，那也就有了账号。没有呢，也没有关系，先去这里 <a href="https://appleid.apple.com/account?localang=en_US&amp;appId=632&amp;returnURL=https%3A%2F%2Fidmsa.apple.com%2FIDMSWebAuth%2Flogin.html%3Flanguage%3DUS-EN%26rv%3D1%26path%3D%252Faccount%252F%26Env%3DUAT%26appIdKey%3D891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757#!&amp;page=create" target="_blank" rel="noopener">注册Apple ID</a> 。</p><p>对于国际信用卡，没有的可以去银行申请（推荐招行），或者跟朋友借。</p><p>开始进入正题：</p><ol><li><p>现在打开 <a href="https://developer.apple.com/programs/cn/" target="_blank" rel="noopener">Apple 开发者</a> 首页，这里可以也找到开发文档、设计指南。（无论是设计师，还是开发者，都应该看下苹果的人机交互指南。）</p></li><li><p>点击右上方的<strong>注册</strong>按钮，跳转页面。</p></li><li><p>跳转后，点击页面底部<strong>开始注册</strong>按钮，跳转页面。</p></li><li><p>输入Apple ID账号和密码，跳转页面。</p></li><li><p>检查上方<strong>Name</strong>后面的拼音是不是真实姓名（如张三，应显示 SAN ZHANG，大小写都行），正确的话进入下一步。（个人开发者，名称必须和身份证上一致！不然付款成功后会要求上传身份证，不一致的话还需要修改并再次上传身份证。如果需要修改，去 <a href="https://appleid.apple.com/#!&amp;page=signin" target="_blank" rel="noopener">Apple ID登录</a> ，在账户区域的右边有个<strong>编辑</strong>，点击进行修改。）</p></li><li><p>选择开发者账号类型，这里选择<strong>Individual / Sole Proprietor / Single Person Business</strong>，即个人开发者类型，点击<strong>Continue</strong>按钮，跳转页面。</p></li><li><p>填写个人信息（如下图），完成后点击<strong>Continue</strong>按钮，跳转页面。</p><img src="/2018/04/11/iOS个人开发者账号申请/01_Info.jpg"></li><li><p>核对信息无误后，点击<strong>Continue</strong>，跳转页面。</p></li><li><p>确认订单，价格：688，期限：1年。点击<strong>Purchase</strong>进行购买。</p></li><li><p>输入信用卡信息，确认账单地址，这里没什么好说的，提示缺啥填啥。直接下一步、下一步、立即下订单。立刻会收到付款成功邮件，就表示成功了。十分钟左右还会收到电子收据邮件。</p></li><li><p>坐等苹果通知。（一般在24h 内通过，可到开发者中心查询状态。如24小时后仍处于<strong>Pending</strong>状态，直接给苹果开发者中心打电话 <strong>4006 701 855</strong> ）</p><p>​</p></li></ol>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发者账号 </tag>
            
            <tag> App Store </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
