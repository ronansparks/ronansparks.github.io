<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>成功？你的人生算法</title>
      <link href="/2018/08/04/091849/"/>
      <url>/2018/08/04/091849/</url>
      <content type="html"><![CDATA[<p><em>人生算法</em> 这个概念是罗振宇在《时间的朋友》2017跨年演讲的结尾提出的。</p><p>下面有两个选项</p><img src="/2018/08/04/091849/01_choice.jpg"><ol><li>按下红色按钮，直接拿走100万。 </li><li>按下蓝色按钮，50%的概率拿到1亿；50%的概率空手而归。</li></ol><p>你会怎么选？（先认真思考下）</p><p>在说到算法之前，先提及另一个词 <em>规律</em>，规律是一成不变的，人们认为它是永恒的。</p><p>在从小到大的学习中，不断地做题，不断地练习。为的是掌握一种规律，掌握了这个规律，就能把题做对，考试能得100分。</p><p>然而现在的世界，不是做题这么简单，它也不是依靠一成不变的规律来运转，而是依靠“算法”来不断优化、提高效率，就像人工智能的自我演化。</p><p>去年谷歌的 AlphaGo 战胜围棋排名世界第一的柯洁，成为人们关注的焦点。</p><p>人生算法，就是像机器一样，不断地寻找基本的方法，反复加强、迭代。</p><p>所有人都知道成功，是无法复制的。</p><p>因为做的每一件事都只是有概率成功，人要取得成功，那就是要把无数的事情都做成功。</p><p>成功，就是不断累加的概率。</p><p>回到开篇那道题，答案是：</p><p>无论你选择按下哪个按钮，你都很可能失败了。你肯定衡量了一下风险，是要稳妥的100万，还是赌一把？如果只是这样思考，肯定不会是赢家。</p><p>正确的选择肯定是蓝色按钮，但别着急按下去，想想有没有其他办法来按呢？</p><p>比如你可以找上你的土豪朋友，说咱俩关系这么好，我这有个一亿的机会，你给我100万，我带你一起去按，中了的话分你一半。</p><p>比如你还可以找到做投行、做金融的，说你有个50%概率获得一亿的机会，很容易算出期望值是5000万，你只要2000千万就卖给他。</p><p>在这样脑洞大开之后，你还能想出无数的方法去实现收益最大化。</p><p>这就是人生算法。当你发现一种方法之后，不要死守着一种方法。你要不断地去做、去优化、去迭代。</p><p> 实干兴邦，读万卷、行万里。</p><p>这首歌的词是吴晓波和罗振宇在2008年写的，也是第一财经于2008推出的纪录片《激荡三十年》片尾曲。</p><img src="/2018/08/04/091849/02_follow.jpg">]]></content>
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 选择 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品的微观视角 - 同理心</title>
      <link href="/2018/07/08/121408/"/>
      <url>/2018/07/08/121408/</url>
      <content type="html"><![CDATA[<p>做产品，本质上是为用户量身定制一套方案。</p><a id="more"></a><p>它可能是帮用户解决现实问题，如解决焦虑、提高效率；也可能是愉悦用户，制造奶头乐、打发时间。</p><img src="/2018/07/08/121408/00_thumb.jpg"><p>做产品，需要从微观、中观、宏观三个层次去考虑，相辅相成。微观是观察最底层的情绪，而底层情绪是需求的最终来源，明白用户要什么，才能给出最优的方案。</p><img src="/2018/07/08/121408/01_structure.jpg"><h1 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h1><h2 id="满足"><a href="#满足" class="headerlink" title="满足"></a>满足</h2><p>“满足”可以用来检验一款产品是否达到它原先设想的目标。</p><img src="/2018/07/08/121408/02_emotions.jpg"><p>如果一个人的需求得到了满足，那他就会很愉悦。</p><p>为什么游戏、短视频能够使人沉迷，因为它提供给了用户多个层面的满足感（社交、好友排行、被崇拜），让用户感到愉悦。联想一下自己，你会丢掉使自己感到愉悦的东西吗？</p><p>如果一个人的需求没有得到满足，那他就会很不爽。</p><p>当你急匆匆地冲进卫生间、发现没有空位；当你看视频看的正爽，一个60秒的广告插播进来；当你打开应用准备扫码骑车，它却拦着你不让你走，先拉着你说几句“我更新啦，你看我更新了这个，还增加了那个，@#￥%”。</p><h2 id="恐惧"><a href="#恐惧" class="headerlink" title="恐惧"></a>恐惧</h2><p>“恐惧”对人有积极的影响，也有消极的影响，同时它也是一个人的痛点。</p><p>恐惧是边界，束手束脚。</p><p>当你看到一堆火的时候，你会不自觉地绕开它，火焰四周高温使你难受的范围，就是一圈边界。</p><p>有的人恐高，可能他这一辈子都不会去蹦极、跳伞，这是他的边界；很多女性朋友拿了驾照很久仍然害怕开车，这是她的边界；有女性遭遇家庭暴力，却不选择离开，这是她的边界（他有温柔的时候、找不到更好的、社会对离异女性的舆论）。小时候跟大人看了《不要和陌生人说话》，烙下了不可磨灭的暴力画面，这种片应该设为 R （限制级）的。</p><p>恐惧是动力，比满足感还能促使人前进。</p><p>在过去，人们害怕与社会脱节，每天都要读报纸；今天，人们害怕与互联网脱节，每天要读许多新闻、公众号；在互联网做技术的，害怕与行业脱节，要不断学习层出不穷的新技术、新框架。</p><p>恐惧是痛点，让人无法理性思考。</p><p>为什么有了那么多对面膜的科普，销量却不见减少？看到周围女生都在用，万一有效呢，自己不用岂不亏大了。这是对青春的恐惧，改掉一种行为，风险太大。</p><p>为什么咪蒙有那么多的追随者？看到其他人都在追，把成功后的她映射到自己，渴望也能成功，不追的话，别人远远超越自己怎么办。这是对未来的恐惧，是渴望成功的焦虑。</p><h1 id="潜意识"><a href="#潜意识" class="headerlink" title="潜意识"></a>潜意识</h1><img src="/2018/07/08/121408/03_heart.jpg"><h2 id="言行不一"><a href="#言行不一" class="headerlink" title="言行不一"></a>言行不一</h2><p>不要看一个人怎么说，而要看他怎么做。</p><p>有个经典的例子，索尼公司推出了一款音箱，有黄色和黑色。公司请来了一批人来做调研，其中问他们喜欢哪个颜色，大多数的人都说喜欢黄色，黄色更好看。调研结束了，公司为了表示感谢，他们可以带走一款音箱，结果出人意料，所有人都拿了黑色的那款。</p><p>他们并不是刻意撒谎，视觉上看上去，可能黄色真的比较好看，然而涉及到自身利益，结合个人生活的时候，选择就变了。</p><h2 id="真实需求"><a href="#真实需求" class="headerlink" title="真实需求"></a>真实需求</h2><p>汽车还不为人所知的时候，福特公司问用户需要什么，他们说想要一匹更快的马；一款相机应用，突然弹窗说想要访问通讯录，用户一下就对它防御了起来；为什么改名加多宝以后，要强调原来的配方，熟悉的味道。</p><p>要避免触碰用户的雷区、触发用户的防御，一旦有了戒心，就很难再更改印象了。制造熟悉感，给用户一种安全、一种确定感，让用户根本不会想起防御。</p><h2 id="用户调研"><a href="#用户调研" class="headerlink" title="用户调研"></a>用户调研</h2><p>大家都知道用户调研，可以了解用户想要什么。</p><p>除了学会挖掘用户真实需求的技巧外，还要使自己保持开放心态，接收不一样的思考方式，加以思考分析。</p><h1 id="角色化"><a href="#角色化" class="headerlink" title="角色化"></a>角色化</h1><img src="/2018/07/08/121408/04_group.jpg"><h2 id="集体人格"><a href="#集体人格" class="headerlink" title="集体人格"></a>集体人格</h2><p>在社会中，与你有过片面之缘的，都不是真的人。</p><p>而是一个角色。</p><p>社会为了运转，企业为了效率，需要批量制造适应某个岗位的人。对一群人设立一样的目标；演示负面的例子；演示成功人士的例子作对比；当你进步了，得到奖赏（金钱、荣誉）；重复。</p><p>这里并不是为了否定角色化的积极意义，而是给出一种思考方式。思考你的产品是为谁设计？</p><h2 id="真实个体"><a href="#真实个体" class="headerlink" title="真实个体"></a>真实个体</h2><p>一位教师就应该处处为别人考虑吗？回到家，就应该不辞辛劳地做饭、做家务么。教师是她在学校的角色，回到家可以扮演妻子的角色，也可以做真实的自己，躺在沙发上，舒适地看电视。</p><p>张小龙说“好的用户体验，目标就是做到自然”。</p><p>为某个群体做产品，最好先充分研究这个群体的群体人格、共同记忆、核心观念。</p><p>为个体做产品，最好抛开对他所处角色的刻板印象，而应把对方当做一个鲜活的人、去了解、研究。</p><p>这是学习梁宁老师的《产品30讲》后，自己做的整理、总结、体会。</p>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同理心 </tag>
            
            <tag> 满足 </tag>
            
            <tag> 恐惧 </tag>
            
            <tag> 潜意识 </tag>
            
            <tag> 真实需求 </tag>
            
            <tag> 角色 </tag>
            
            <tag> 微观 </tag>
            
            <tag> 心理学 </tag>
            
            <tag> 集体人格 </tag>
            
            <tag> 产品 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《产品思维30讲》人的五个层次</title>
      <link href="/2018/06/29/150424/"/>
      <url>/2018/06/29/150424/</url>
      <content type="html"><![CDATA[<p>成长之路，一路迂回崎岖，渐渐理解了产品思维的重要性，对梁宁老师所说的“产品是每个人的底层能力”深有感触。</p><a id="more"></a><p>有人会画原型、写文档；</p><p>有人会选配色、定交互；</p><p>有人会写界面、写底层。</p><p>满足吗？</p><p>《产品思维30讲》梁宁老师在《得到》开的专栏，受益匪浅。</p><p>下面这五个层次是看产品的专业化方法，也可以对应着来了解人这款“产品”。有人把这些方法应用到生活中，做起了结婚教练。</p><img src="/2018/06/29/150424/01_frame.png"><h1 id="感知层"><a href="#感知层" class="headerlink" title="感知层"></a>感知层</h1><p>感知是指人最原始的表现，是通过五官接触到的。</p><p>一款产品外形好不好，颜色喜不喜欢；这衣服样式喜不喜欢，手感怎么样；一个人身材、谈吐如何，穿着搭配怎么样。</p><img src="/2018/06/29/150424/02_sense.jpg"><h1 id="角色框架层"><a href="#角色框架层" class="headerlink" title="角色框架层"></a>角色框架层</h1><p>角色，画重点，之后也会再强调。</p><p>在生活的大部分时间里，我们都是“演员”。</p><p>早晨的时候，扮演邻居角色，不会大声吵闹影响别人；坐地铁的时候，扮演乘客角色，不会吃臭豆腐，文明礼让；上班时候，扮演员工，认真做事以求得到赏识；下班时候，扮演膏药贴，安慰失恋的朋友。</p><p>为什么常说不要 judge 一个人，因为你接触到的可能只是他扮演的其中一个角色而已，你并不了解他。</p><img src="/2018/06/29/150424/03_role.jpg"><h1 id="资源结构层"><a href="#资源结构层" class="headerlink" title="资源结构层"></a>资源结构层</h1><p>每个人的财富资源、人脉资源、精神资源都不同。</p><p>然而你也可以拍着胸脯说某某原来是我小学同学，这是因为你们都扮演过同样的角色。</p><p>上同一个小学，读同样的九年义务教育，有些人看上去腰间就是比较突出。这是因为在成长过程中，不同的资源结构，推动每个人，去往不同的地方。</p><p>如果对一款产品、一个人的分析只停留在感知层、角色层，那就只看到了表面，用产品术语来说叫“只抓表面数据”。</p><img src="/2018/06/29/150424/04_resource.jpg"><h1 id="能力圈"><a href="#能力圈" class="headerlink" title="能力圈"></a>能力圈</h1><p>能力圈存放着每个人的各种能力。</p><p>为了达到目的，为了得到满足，每个人都拼命地学习，接触各方面的知识，扩大自己的能力圈。</p><p>一万小时定律、斜杠青年、跨界，都是对能力的描述。</p><img src="/2018/06/29/150424/05_skill.jpg"><h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><p>内核是一个人对自己存在感的定义。</p><p>我是谁？我从哪里来？我要到哪里去？</p><p>对于动物，生存条件满足后，就感到愉悦。</p><p>对于人，为什么会焦虑、不安、上窜下跳？因为他的存在感没有得到满足。</p><p>而对于不同人，满足阈值也不同，满足了就不想再前行，没动力再扩大能力圈。这也解释了为什么有时两人关系，会从曾经的无话不谈变成如今尬聊的情形。</p><p>人的内核就像手机的操作系统，你是 Android 还是 iOS？是否还要更新迭代？很大程度上决定了一个人的发展。</p><img src="/2018/06/29/150424/06_core.jpg"><p>梁宁老师最后举了个例子，她在2005年认识了正在做豆瓣的阿北、做抓虾的徐易容、做校内网的王兴。</p><p>如今，十三年过去了。</p><p>王兴和美团。</p><p>徐易容和美丽说。</p><p>阿北和他的豆瓣，豆瓣还是那个豆瓣。</p>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维、感知、角色、资源、能力、内核、产品 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品《启示录》笔记</title>
      <link href="/2018/06/24/105712/"/>
      <url>/2018/06/24/105712/</url>
      <content type="html"><![CDATA[<p>为什么每个人都需要养成产品思维？一款好的产品不是靠产品经理就能完成，一款好的产品也不是只凭技术就可以实现从0到100。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。</p></blockquote><img src="/2018/06/24/105712/00_thumbnail.jpg"><p>一本关于如何打造用户喜爱的产品的书籍，《启示录》。作者是硅谷产品集团的创始人 Marty Cagan，该集团致力于帮助软件企业制定产品策略、完善研发流程、打造用户满意的软件产品。</p><p>该书在豆瓣有5k+ 的评分，平均分8.5。</p><p>本文的目的在于梳理书籍结构，整理内容，便于记忆和索引，完整内容仍在书中。</p><blockquote><p>好产品具备的三个基本条件：价值、可用性、可行性。</p></blockquote><p>产品经理的主要工作做什么？有人说是管人，有人说是写需求，有人说是背锅（摊手.gif）。</p><p>主要工作有以下三个方面：</p><ol><li>人员</li><li>流程</li><li>产品</li></ol><img src="/2018/06/24/105712/01_structure.png"><h1 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h1><p>产品经理，它就像王者荣耀中的打野，除自身技能和意识外，开好团很重要。首先需要找机会蹲一波（评估产品机会），接着上去就是一套技能（探索解决方案）。</p><p>交互设计师，实际上用户体验是由交互 + 视觉决定，但前期这里更多的是与交互设计师有关。需要深入理解用户需求、设计主要功能、设计用户导航、创建用户体验地图。</p><p>项目人员，由专业的项目经理负责制定计划、跟踪进度。有时也由产品经理、或技术 Leader 主导。</p><p>开发人员，使得产品实现从0到1的跨越。因此与开发人员沟通清楚产品的目的，同时又留给他们技术实现的空间非常重要。</p><p>运维团队，保障整个服务的正常运行。</p><p>营销团队，负责宣传产品、组织营销活动、传播、拉新。</p><p>同时书中还对比产品管理与其他相近岗位的各自职责，相同与不同之处。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>“流程”是本书的重点，作者花了一半的笔墨在这上面。</p><p>这部分给出了很多可复用的流程，也讲述了作者经历和知道的部分成功实践经验。</p><p>像是前期准备流程中的评估机会、制定产品原则、市场调研等；后期验证和开发中的 MVP（最小可行性产品）、原型测试等都可用拿过来，结合自己产品情况，全部或部分采纳。</p><p>顺便读一读前人的经验，扩充知识库。</p><p>由于是具体的操作，作者着墨较多，无法在短短一篇文章中展现，请参考上方思维导图作索引之用。</p><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><p>苹果公司，是公认为用户体验最好的公司，也是各界大佬争相学习的榜样。硬件为软件服务、软件为体验服务、体验为情感服务、产品为真实需求服务。也难怪乔布斯会说用户不知道他们想要什么，直到你给出了他们想要的。见贤思齐焉，向优秀的人/企业学习，总是不会让你空手而归。</p><p>关于产品创新，我想来自《圣经》一句话，“太阳之下，本无新事”最能概括了。第一次是在3Q大战之际，听小马哥说过，当时年少不以为然，后来接触越多，体会越深。昨日热炒的共享经济、VR，今日的区块链都不是突然之间出现的，技术从0到1是种突破，从1到100是最大的成功。</p><p>作者还给出了面向消费者、面向企业、以及平台级产品的一些经验和建议。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="实现模型-vs-概念模型"><a href="#实现模型-vs-概念模型" class="headerlink" title="实现模型 vs 概念模型"></a>实现模型 vs 概念模型</h2><p>实现模型：产品是如何工作的。</p><p>概念/心理模型：用户认为是怎样工作的。</p><p>表现模型：通过设计来封装实现模型，让用户认为产品是这样工作的。</p><img src="/2018/06/24/105712/02_model.jpg"><h2 id="火车模型发布-vs-流水线发布"><a href="#火车模型发布-vs-流水线发布" class="headerlink" title="火车模型发布 vs 流水线发布"></a>火车模型发布 vs 流水线发布</h2><p>火车模型：按固定周期发布产品。到了发布截至时，未完成功能放到到下个版本迭代。</p><p>流水线模型：多个模块同时开发。当1.0进入项目执行阶段，就可以开始2.0的定义。</p><p>下面这张图来自 FireFox 团队（图片来自网络），可以看到时间差距很大。</p><img src="/2018/06/24/105712/03_distribute.jpg"><h2 id="瀑布式开发-vs-敏捷开发"><a href="#瀑布式开发-vs-敏捷开发" class="headerlink" title="瀑布式开发 vs 敏捷开发"></a>瀑布式开发 vs 敏捷开发</h2><p>瀑布式开发：比较过时的方法。严格遵循预先计划的需求、分析、设计、编码、测试等顺序。有论文统计这是造成70%软件开发失败的原因。</p><p>敏捷开发：以用户需求进化为核心，采用迭代、循序渐进的方式进行开发。</p><p>下面这张图对比十分形象（图片来自网络）。</p><img src="/2018/06/24/105712/04_development.jpg"><h2 id="用户净推荐值"><a href="#用户净推荐值" class="headerlink" title="用户净推荐值"></a>用户净推荐值</h2><p>用户净推荐值（NPS）：通俗的说法就是“口碑”。计量某个客户将会向其他人推荐产品或服务可能性的指数。</p><p>净推荐值 = （推荐者人数 / 总样本人数）X 100% - （贬损者人数 / 总样本人数）x 100%</p><p>得分注解：</p><ul><li>9-10为狂热粉，会推荐给其他人；</li><li>7-8分为被动者，总体上满意，摇摆型；</li><li>0-6分为贬损者，不满意也不具有忠诚性。</li></ul><h1 id="作者总结和建议"><a href="#作者总结和建议" class="headerlink" title="作者总结和建议"></a>作者总结和建议</h1><p>同流程部分一样，感兴趣的内容，都可以在书中找到。</p><ul><li>成功产品的10条规律</li><li>优秀产品经理的7个特点</li><li>开发帮助完善产品定义的3种方式</li><li>开发配合产品经理双打野产品定义的3种方式</li><li>产品经理如何辅助开发</li><li>异地开发沟通的3条建议</li><li>关于代码重构的决策</li><li>如何招聘和管理产品经理的</li><li>“管理”上司的10条经验</li><li>开发新产品还是维护旧产品</li><li>敏捷方法的10大秘诀</li><li>跳出大公司条条框框的10大秘诀</li><li>最佳实践经验10大要点</li><li>产品经理该反省的10大问题</li></ul>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 人员 </tag>
            
            <tag> 流程 </tag>
            
            <tag> 产品管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift 4.2 什么值得看？</title>
      <link href="/2018/06/20/161557/"/>
      <url>/2018/06/20/161557/</url>
      <content type="html"><![CDATA[<p>今年的 WWDC 没有发布硬件产品，那就来看看 Swift 4.2 更新了哪些特性把 :D</p><a id="more"></a><img src="/2018/06/20/161557/00_thumb.png"><p>只是光看着不动手也不过瘾，装个 <a href="https://developer.apple.com/download/" target="_blank" rel="noopener">Xcode10 Beta</a> 就可以抢先体验新特性啦。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>什么是 Swift 4.2？</p><p>？？！！</p><p>看看大神们在开发 Swift 4.2 前立的 flag ：</p><ul><li>更快的编译速度</li><li>新增可提高效率、移除模板代码的语言特性</li><li>SDK 针对 Swift 优化</li><li>提升 ABI（Application Binary Interface）兼容性</li></ul><h2 id="源码兼容性"><a href="#源码兼容性" class="headerlink" title="源码兼容性"></a>源码兼容性</h2><p>一个编译器，三种模式：</p><ul><li>Swift 3</li><li>Swift 4</li><li>Swift 4.2</li></ul><p>Xcode 将兼容之前的两个大版本，三种模式都可以使用新的 API 和语言特性。可以在 <code>TARGETS -&gt; Build Setting -&gt; Swift Compiler - Language</code> 下更改。</p><img src="/2018/06/20/161557/01_compile.png"><h2 id="更快的调试编译"><a href="#更快的调试编译" class="headerlink" title="更快的调试编译"></a>更快的调试编译</h2><p>在 Xcode 10 上调试编译速度更快。</p><p>下图是在 Macbook Pro 四核 i7 上的运行测试结果。从图中可以看到，Wikipedia 是 Objective-C 和 Swift 混编的项目，在 Xcode 10 上构建速度比在 Xcode 9 上提升了1.6倍。而对于大多数的项目，会提高至少2倍的速度。</p><img src="/2018/06/20/161557/02_wikipedia.png"><p>两种编译模式：</p><ul><li>增量化编译（Incremental）：逐个文件编译</li><li>模块化编译（Whole Module）：整个模块编译</li></ul><p>在 Xcode 10上，默认是增量化编译。</p><p>使用增量化编译全部编译一次，速度比模块化编译慢，但之后修改一次只需编译相关的文件，而非编译整个模块，速度更快。</p><p>这样的话，可以针对项目中不常改动的部分（如 Pod），使用模块化编译，在 Podfile 中添加下面代码。</p><pre><code class="ruby">post_install do |installer|  # 提高 pod 库编译速度  installer.pods_project.targets.each do |target|    target.build_configurations.each do |config|      config.build_settings[&#39;SWIFT_COMPILATION_MODE&#39;] = &#39;wholemodule&#39;      if config.name == &#39;Debug&#39;        config.build_settings[&#39;SWIFT_OPTIMIZATION_LEVEL&#39;] = &#39;-Onone&#39;      else        config.build_settings[&#39;SWIFT_OPTIMIZATION_LEVEL&#39;] = &#39;-Osize&#39;      end    end  endend</code></pre><h2 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h2><p>Swift 也是使用 ARC 进行内存管理，使用 <code>Owned（持有）</code>模型。每次被调用，都会发生持有、释放的操作，这样会执行许多持有和释放的操作，如下图</p><img src="/2018/06/20/161557/03_owned.png"><p>Swift 4.2 改为 <code>担保（Guaranteed）</code>模式后，不再需要持有，性能表现更好，编译的二进制文件也更小。</p><img src="/2018/06/20/161557/04_guaranteed.png"><p>目前在64位平台上，String 使用了16字节进行编码。更新后，将使用15字节对小的字符串，利用剩下的来存储相关信息，而非重新申请空间存储。</p><img src="/2018/06/20/161557/05_string.png"><h2 id="减少代码大小"><a href="#减少代码大小" class="headerlink" title="减少代码大小"></a>减少代码大小</h2><p>打包时可以在 <code>TARGETS -&gt; Build Setting -&gt; Swift Compiler - Language</code> 下设置，更改为优化大小。</p><p>代码大小能降低10% - 30%，然而牺牲5%的性能。</p><p>有时多5%的性能，用户不关心，但在下载应用的时候，会注意应用的大小。当然具体就结合个人/公司的具体情形考虑。</p><h1 id="语言新特性"><a href="#语言新特性" class="headerlink" title="语言新特性"></a>语言新特性</h1><h2 id="可遍历枚举"><a href="#可遍历枚举" class="headerlink" title="可遍历枚举"></a>可遍历枚举</h2><p>在之前为了遍历枚举，需要手动写个静态属性，增删了case之后，还得修改该属性。然而现在不再这么麻烦，继承<code>CaseIterable</code> 协议，便可自动获得 buff 加成，可直接调用<code>.allCases</code> 属性</p><img src="/2018/06/20/161557/06_enum.png"> <h2 id="条件一致性"><a href="#条件一致性" class="headerlink" title="条件一致性"></a>条件一致性</h2><p>条件一致性是指泛型类型在特定条件下回遵循一个特定的协议。</p><p>如下图所示，前面可以使用 <code>contains(_:)</code>方法检查是否有包含某个元素，然而后面不可以用它来检查一个数组是否包含在一个另一个数组中。因为数组只有在它的元素遵循 <code>Equatable</code> 的时候遵循 <code>Equatable</code> 。</p><img src="/2018/06/20/161557/07_conformance.png"><p>但是现在你可以做到了！同 Swift 4.1 时为 <code>Codable</code> 引入的自动实现一样，现在也为 <code>Equatable</code> 和 <code>Hashable</code> 引入了自动实现。</p><p>有了 <code>Hashable</code> 不再需要自己实现哈希算，只需在 <code>hasher.combine(_:)</code> 中传入想要哈希的值。</p><pre><code class="swift">struct City {    let name: String    let state: String    let population: Int}extension City: Hashable {    func hash(into hasher: inout Hasher) {        name.hash(into: &amp;hasher)        state.hash(into: &amp;hasher)    }}</code></pre><h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>随机数的生成需要去系统中获取变量生成随机种子，因此在不同平台需要调用不同的随机数 API，如下图。</p><img src="/2018/06/20/161557/09_random.png"><p>在 Swift 4.2 中实现了跨平台的随机数 API。</p><pre><code class="swift">Int.random(in: 1...1000)UInt8.random(in: .min ... .max)Double.random(in: 0..&lt;1)// 返回单个随机的元素let emotions = &quot;😀😂😊😍🤪😎😩😭😡&quot;let randomEmotion = emotions.randomElement()!// 返回打乱的数组let numbers = 1...10let shuffled = numbers.shuffled()</code></pre><p>当然也可以自己定义随机数算法。</p><h2 id="检查平台"><a href="#检查平台" class="headerlink" title="检查平台"></a>检查平台</h2><p>一直以来，为了跨平台，需要检查不同平台。其实目的并不是为了检查平台，而是为了确保能引入对应的库，在第三方库里很常见。</p><pre><code class="swift">#if os(iOS) || os(watchOS) || os(tvOS)  import UIKit#else  import AppKit #endif</code></pre><p>所以现在呢，可以直接检查是否能引入某个库</p><pre><code class="swift">#if canImport(UIKit)   import UIKit#elseif canImport(UIKit)  import AppKit#else  #error(&quot;Unsupported platform&quot;)#endif</code></pre><p>是的，你也看到了吧，引入了 <code>#error</code>，另外还有 <code>#warning</code> ，不再需要写</p><pre><code class="swift">// FIXME: I&#39;ll come back later</code></pre><h2 id="隐式解析可选值"><a href="#隐式解析可选值" class="headerlink" title="隐式解析可选值"></a>隐式解析可选值</h2><p>隐式解析可选择(Implicitly Unwrapped Optionals)，简称 IUO。它是一个声明的属性而不是表达式类型。</p><p>IUO 不可以作为其他类型的一部分</p><pre><code class="swift">let array: [Int!] = [3] // 会报错print(array[0])</code></pre><p>然而你在 Swift 4.0 可以绕过它达到目的</p><pre><code class="swift">typealias T = Int!let array: [T] = [3]print(array[0])</code></pre><p>在 Swift 4.2 屏蔽了这种方式，如果你有这样做，需要改过来。</p><h1 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h1><p>Ole 大神已经用 <a href="https://github.com/ole/whats-new-in-swift-4-2" target="_blank" rel="noopener">代码</a> 将 Swift 4.2 的新特性演示了一遍，你只需要下载 Xcode 10，下载链接中的文件就可以细细看啦。</p>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> enum </tag>
            
            <tag> RNG </tag>
            
            <tag> platform </tag>
            
            <tag> WWDC </tag>
            
            <tag> Apple </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift 面向协议编程</title>
      <link href="/2018/06/14/232928/"/>
      <url>/2018/06/14/232928/</url>
      <content type="html"><![CDATA[<p>提起编程，大多数人第一反应就是面向对象编程，张口就来“封装、继承、多态“，可见影响之深。</p><p>OOP 已经这么成熟了，那么为什么还需要面向协议（POP）呢？</p><p>或许你已经开始写了些 Swift 代码，或许你还在写 Objective-C，如果花点时间了解 POP，相信你会爱上它的。</p><p>Swift 不止是一门新的语言，更是一种新的编程思考方式。</p><blockquote><p>Swift 是第一个面向协议的编程语言。</p><p>— <a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">WWDC 2015</a></p></blockquote><p>Swift 2 引入了协议扩展，提出了面向协议编程的概念。这场是由 Dave Abrahams （Swift 标准库的负责人）演讲的，列举了 OOP 的问题，以及如何通过 POP 解决这些问题，建议去看看（PS：他的肢体语言、冷笑话风格和《硅谷》里的 Richard 很像 :D）。</p><img src="/2018/06/14/232928/01_thumb.jpg"><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在面向对象的世界的里，以类为思考方式，每个类有自己的属性和方法。</p><p>工作忙碌一天后回到家，你把温度器打开，设置到 27 度</p><pre><code class="swift">// 温度控制器class Thermometer {    // 温度（摄氏度）    var temperature: Int = 0}let thermometer = Thermometer()thermometer.temperature = 27// 房间class Home {    var thermometer: Thermometer?}// 设置房间温度 27let home = Home()home.thermometer = thermometer</code></pre><p>玩了会 AR 游戏，突然肚子饿了，于是你下楼把烤箱打开，设置温度到 200 度，准备烤点什么</p><pre><code class="swift">// 烤箱class Oven {    var thermometer: Thermometer?}// 设置烤箱温度 200let oven = Oven()oven.thermometer = thermometerthermometer.temperature = 200print(&quot;房间温度：\(home.thermometer!.temperature)&quot;)print(&quot;烤箱温度：\(oven.thermometer!.temperature)&quot;)</code></pre><p>你猜怎么着？</p><p>“嘣”，一不小心把自己变成了爆米花。你打开日志一看</p><pre><code class="swift">房间温度：200烤箱温度：200</code></pre><p>使用结构（Struct）可以解决引用问题，更多内容链接文章末尾。首选结构体，只有确定需要用到类的特性时，才使用类。</p><img src="/2018/06/14/232928/02_POP.png"><h1 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h1><p>协议中包含属性和待实现的方法定义。</p><p>协议/接口一点也不稀奇，Objective-C、Java都有。声明协议/接口，让具体的子类去实现。</p><p>如果你有多个类继承了这个协议，还需要在每个类中写一遍。有经验的你，一定会想办法避免在多个地方写相同的代码。</p><p><strong>协议扩展</strong> 了解一下？</p><p>在协议扩展中，提供默认实现。具体的子类只需要继承该协议，不用再写一行代码，就可以轻松集成新功能。</p><pre><code class="swift">// 协议声明protocol DrawSomething {    func drawCircle(center: CGPoint, radius: CGFloat)    func drawLine(start: CGPoint, end: CGFloat)}// 协议扩展extension DrawSomething {    func drawCircle(center: CGPoint, radius: CGFloat) {        print(&quot;Draw a circle from the center: \(center), radius: \(radius)&quot;)    }    func drawLine(start: CGPoint, end: CGFloat) {        print(&quot;Draw a line from \(start) to \(end)&quot;)    }}struct MyCircle: DrawSomething {}let myCircle = MyCircle()myCircle.drawCircle(center: CGPoint(x: 0, y: 0), radius: 10)myCircle.drawLine(start: CGPoint(x: 0, y: 0), end: 5)// 控制台输出// Draw a circle from the center: (0.0, 0.0), radius: 10.0// Draw a line from (0.0, 0.0) to 5.0</code></pre><p>从面向对象编程转换到面向协议编程，要注意的几点：</p><ul><li>优先考虑协议，而不是父类。</li><li>优先考虑值类型，而不是类。</li><li>善用协议扩展的超能力。</li></ul><p>更多链接：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">使用 Swift 面向协议编程 - WWDC 2015 视频</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="noopener">使用 Swift 值类型构建更好的应用 - WWDC 2015 视频</a></li><li><a href="https://blog.csdn.net/felicity294250051/article/details/79026969" target="_blank" rel="noopener">实战面向协议编程和协议扩展</a></li></ul>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> protocol </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用SnapKit布局</title>
      <link href="/2018/06/11/233437/"/>
      <url>/2018/06/11/233437/</url>
      <content type="html"><![CDATA[<p>SnapKit 是一门在 iOS 和 OS X 上的的领域特定语言（Domain Specific Language），简化自动布局，使用 Swift 语言编写。它有以下几点特征：</p><ul><li>简单 &amp; 表示清晰：DSL 链可以使用很少的代码添加约束，并保持易读、易理解。</li><li>类型安全：通过设计，减少了人为错误、且避免无效的约束被创建。</li><li>兼容性：iOS 和 OS X 平台可用，可使用 Cocoapods 和 Carthage 安装。</li><li>免费：MIT 开源许可。</li></ul><p>当前版本是 4.0，使用 <code>pod &#39;SnapKit&#39;, &#39;~&gt; 4.0&#39;</code> ，最新版本和其他安装方式可上 <a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">Github</a> 查看。</p><p>还可以下载查看 <a href="https://github.com/ronansparks/SnapKitDemo.git" target="_blank" rel="noopener">SnapKitDemo</a>，简单写了几个示例。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>新建 <code>SingleView</code> 工程，在 <code>viewDidLoad</code> 中添加下面方法。新建了一个橙色的 UIView，宽高都是 100，中心与 self.view 重合。</p><pre><code class="swift">let box = UIView()box.backgroundColor = .orangeview.addSubview(box)box.snp.makeConstraints { (make) in    make.size.equalTo(100)    make.center.equalTo(view)}</code></pre><p><strong>注意：</strong>必须先把要布局的视图添加到父容器中，再调用布局，否则会崩溃。</p><h2 id="约束参数"><a href="#约束参数" class="headerlink" title="约束参数"></a>约束参数</h2><ul><li><code>.equalTo</code> 相等</li><li><code>.lessThanOrEqualTo</code> 小于等于</li><li><code>.greaterThanOrEqualTo</code> 大于等于</li></ul><p><code>&lt;=</code> 和 <code>&gt;=</code> 基本都可以使用 <code>=</code> 代替；同时设置 <code>&lt;=</code> 和 <code>&gt;=</code>，结果以 <code>&gt;=</code> 为准；</p><p>这三种约束都接受一个参数，支持下面三种参数</p><ol><li>视图属性参数</li></ol><table><thead><tr><th>ViewAttribute</th><th>NSLayoutAttribute</th></tr></thead><tbody><tr><td>view.snp.left</td><td>NSLayoutAttribute.left</td></tr><tr><td>view.snp.right</td><td>NSLayoutAttribute.right</td></tr><tr><td>view.snp.top</td><td>NSLayoutAttribute.top</td></tr><tr><td>view.snp.bottom</td><td>NSLayoutAttribute.bottom</td></tr><tr><td>view.snp.leading</td><td>NSLayoutAttribute.leading</td></tr><tr><td>view.snp.trailing</td><td>NSLayoutAttribute.trailing</td></tr><tr><td>view.snp.width</td><td>NSLayoutAttribute.width</td></tr><tr><td>view.snp.height</td><td>NSLayoutAttribute.height</td></tr><tr><td>view.snp.centerX</td><td>NSLayoutAttribute.centerX</td></tr><tr><td>view.snp.centerY</td><td>NSLayoutAttribute.centerY</td></tr><tr><td>view.snp.lastBaseline</td><td>NSLayoutAttribute.lastBaseline</td></tr></tbody></table><pre><code class="swift">// 设置当前视图宽度等于 view1 的宽度make.width.equalTo(view1.snp.width)</code></pre><ol start="2"><li>视图参数</li></ol><pre><code class="swift">// 使当前视图的中心 x 坐标等于 view1 的中心 x 坐标make.centerX.equalTo(view1)// 等同于 // make.centerX.equalTo(view1.snp.centerX)</code></pre><ol start="3"><li>严格检测参数（常量值）</li></ol><pre><code class="swift">// 设置当前视图宽度为 100，距顶部 40make.width.equalTo(100)make.top.equalTo(40)</code></pre><h2 id="布局灵活性"><a href="#布局灵活性" class="headerlink" title="布局灵活性"></a>布局灵活性</h2><h3 id="布局灵活"><a href="#布局灵活" class="headerlink" title="布局灵活"></a>布局灵活</h3><p>如果宽、高相等，下面几种方式都一样</p><pre><code class="swift">// 1 //make.width.equalTo(100)//make.height.equalTo(100)// 2 使用串联写法//make.width.height.equalTo(100)// 3(推荐写法)make.size.equalTo(100)</code></pre><p>视图左边位置在 view1 左边 + 10，三种方式都一样</p><pre><code class="swift">// 1//make.left.equalToSuperView().offset(10)// 2make.left.equalTo(10)// 3//make.left.equalTo(view1.snp.left).offset(10)</code></pre><h3 id="优先级（priority）"><a href="#优先级（priority）" class="headerlink" title="优先级（priority）"></a>优先级（priority）</h3><pre><code class="swift">make.top.equalTo(label.snp.top).priority(600)// 快捷方式：.low, .medium, .high, .required，数值分别为 250, 500, 750, 1000make.top.equalTo(label.snp.top).priority(.medium)</code></pre><p><strong>注意：</strong>优先级数值最高为 1000，超过会导致崩溃。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><strong>edges</strong></p><pre><code class="swift">// top, left, bottom, right 都等于 view1make.edges.equalTo(view1)// top = superview.top + 5// left = superview.left + 10// bottom = superview.bottom - 15// right = superview.right - 20make.edges.equalToSuperview().inset(UIEdgeInsets(top: 5, left: 10, bottom: 15, right: 20))</code></pre><p><strong>size</strong></p><pre><code class="swift">// width 和 height 大于等于 titleLabelmake.size.greaterThanOrEqualTo(titleLabel)// width = superview.width + 100// height = superview.height + 100make.size.equalToSuperview().offset(100)</code></pre><p><strong>center</strong></p><pre><code class="swift">// centerX 和 centerY 分别等于 button1 的 centerX 和 centerYmake.center.equalTo(button1)// centerX = superview.centerX + 5// centerY = superview.centerY + 5make.center.equalToSuperview().offset(5)</code></pre><p><strong>链式</strong></p><pre><code class="swift">// 顶部与 view1 顶部对齐，左、右、下与 superview 对齐make.left.right.bottom.equalToSuperview()make.top.equalTo(view1)</code></pre><h2 id="更新约束"><a href="#更新约束" class="headerlink" title="更新约束"></a>更新约束</h2><ol><li>引用</li></ol><pre><code class="swift">// 全局属性var topConstraint: Constraint? = nil// make 约束view1.snp.makeConstraints { make in    self.topConstraint = make.top.equalToSuperview().offset(40).constraint    make.left.bottom.right.equalToSuperview()}// 更新约束（比如按钮点击方法中）self.topConstraint.updateOffset(10)</code></pre><ol start="2"><li>snp.updateConstraints</li></ol><pre><code class="swift">// Apple 建议在此方法中添加/更新约束override func updateConstraints() {    self.view2.snp.updateConstraints { make in        make.size.equalTo(200)    }   // 必须调用     super.updateConstraints()}</code></pre><ol start="3"><li>snp.remakeConstraints</li></ol><p>与 <code>snp.makeConstraints</code> 相似，不过这个会先移除 SnapKit 为该视图添加的所有约束。</p><ol start="4"><li>对齐 safeArea</li></ol><pre><code class="swift">view1.snp.makeConstraints { make in    if #available(iOS 11, *) {        make.top.equalTo(self.view.safeAreaLayoutGuide.snp.top)    }     else {        make.top.equalTo(self.view.snp.top)    }}</code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>.labeled</code> 可以打印输出该约束</p><pre><code class="swift">button.snp.makeConstraints { (make) -&gt; Void in    make.top.equalTo(otherView).labeled(&quot;buttonViewTopConstraint&quot;)}</code></pre><h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><p>建议也查看下面几篇文章，以便加深理解。</p><p><a href="http://snapkit.io/docs/" target="_blank" rel="noopener">SnapKit 官方文档</a></p><p><a href="https://www.jianshu.com/p/2bad53a2a180" target="_blank" rel="noopener">langkee 简书</a></p><p><a href="http://www.hangge.com/blog/cache/detail_1097.html" target="_blank" rel="noopener">航哥</a></p>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> SnapKit </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发者视角看WWDC 2018 Keynote</title>
      <link href="/2018/06/06/121727/"/>
      <url>/2018/06/06/121727/</url>
      <content type="html"><![CDATA[<p>又到了每年一次的苹果开发者大会，今年没有发布任何硬件产品，只是对四大平台（iOS，watchOS，tvOS，macOS）进行了更新。</p><p>野猫君将带你从开发者视角看完这场发布会，如何提前储备技能，为下一个机会做准备。</p><img src="/2018/06/06/121727/00.jpg"><h1 id="版本-设备兼容"><a href="#版本-设备兼容" class="headerlink" title="版本/设备兼容"></a>版本/设备兼容</h1><p>现有的系统版本 iOS 11已经覆盖了 81% 的苹果设备，iOS 10 覆盖了 14%，两个版本加起来覆盖了 95%的设备（数据来源于发布会公布的数据和 <a href="https://developer.apple.com/support/app-store/" target="_blank" rel="noopener">开发者官网</a>）。因此开发的时候，支持新功能还是兼容旧版本，可以结合自家业务来做决定。</p><p>iOS 12 将支持 2013 以来到现在的所有 iPhone、iPad，最早的是 iPhone 5s、iPad mini 二代、iPad Air 一代，开发的时候，还要考虑如何兼容这些设备。</p><p>新版本调整了 CPU 的策略，将在打开应用的瞬间提高 CPU，然后缓降，这样换来的效果是（以 6 plus 为测试对象）：</p><ul><li>邮件应用启动速度提高 40%</li><li>键盘弹出完成速度提高 50%</li><li>相机打开速度提高 70%</li><li>系统分享框弹出速度提高到 2 倍</li><li>应用启动速度提高到 2 倍</li></ul><img src="/2018/06/06/121727/01.png"><h1 id="iOS-12"><a href="#iOS-12" class="headerlink" title="iOS 12"></a>iOS 12</h1><h2 id="AR-相关"><a href="#AR-相关" class="headerlink" title="AR 相关"></a>AR 相关</h2><p>联合皮克斯工作室推出了名为 <strong>USDZ</strong> 的新格式，专用于存储 AR 图像，可以通过 iMessage、邮件、网络传播。</p><p>发布了 <strong>ARKit 2.0</strong>，主要提升了面部追踪、真实感渲染、3D 物品检测、持久化的体验（可存储）、共享体验（多玩家联机）。最后一点，无疑增加了更多的趣味性和黏性。现场演示了基于乐高积木的 AR 多玩家游戏。</p><p>系统将自带 <strong>Measure</strong> 应用，用于测量长度、矩形宽高。App Store 里现有的 AR 测量应用将洗牌。</p><p><strong>开发者看点：</strong>现阶段苹果在推出各种 AR 工具，赋能给开发者；随后可能会大量应用在游戏、教育、生活中。作为开发者，要尽快储备技能，顺势而为，坐上风口。</p><img src="/2018/06/06/121727/02.png"><h2 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h2><p>新增 <strong>Shortcuts</strong> 应用，将于秋季推出。你可以自定义事件名称和一连串的操作，使用的时候告诉 Siri，这些事件便会依次执行。如果你用过 Workflow，那你应该很熟悉这些操作，没错，这正是基于去年苹果收购的 Workflow。</p><p>不过你现在也可以尝鲜：首先启动一次地图、电话、备忘录、浏览器等，接着就可以在 Siri 设置中自定义。不过野猫君还没有探索出怎样把它玩出花儿来。</p><p><strong>开发者看点：</strong>可以看做是增强版的语音入口，苹果开放了能力，剩下的就是开发者们自己去争夺用户入口。</p><img src="/2018/06/06/121727/03.png"><h2 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h2><p>勿扰模式：开启勿扰模式后，推送通知将不会出现在锁屏页面。</p><p>通知中心：新版本可以分组显示推送通知；可以在锁屏页面快捷关闭应用的通知；Siri 会建议用户关闭很少使用、却经常推送的应用。</p><p><strong>开发者看点：</strong>推送通知不要骚扰用户，不然用户顺手就把你关进小黑屋。</p><img src="/2018/06/06/121727/04.png"><h2 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h2><p>图片应用：新增了基于 AI 的图片搜索，可搜索类别、标签、人物、地点，识别出照片中的好友并建议分享给他们。</p><p>屏幕时长监控：每周会生成报告，关于各应用、夜间使用频率、哪款应用诱导你解锁屏幕的次数多。</p><p>Animoji &amp; Memoji：Animoji 新增舌头👅识别，新增几个新的👻、🐨、🐅。Memoji是什么呢？就是定义你自己的角色（发型、面部、装饰等）。</p><p>FaceTime：支持群组视频通话，最多 32 个人。</p><img src="/2018/06/06/121727/05.png"><h1 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h1><p>iOS 会和 macOS 融合吗？</p><p>官方回答不会；长期，还是有可能。</p><p>新系统中加入了<strong>UIKit</strong>，目前从 iOS 那边移植了“新闻”、“股票”等几款应用。不过等到 2019 才会向开发者开放移植功能。</p><img src="/2018/06/06/121727/06.png"><p>新增夜间模式，Xcode 也新增了夜间模式，非常好看。</p><img src="/2018/06/06/121727/07.png"><p>新增桌面一键整理功能。</p><img src="/2018/06/06/121727/08.jpg"><p>新增截屏后标注功能，和现在 iPhone 上的截屏一样。</p><p>新增从电脑上的应用中唤起手机摄像头，在手机拍摄 / 扫描后，回传给电脑上的应用。</p><p>新增对位置、联系人、摄像头、麦克风的权限，应用要用到这些功能，需要先申请。</p><img src="/2018/06/06/121727/09.png"><p>改进后的 Finder 支持 pdf + image 一键合成 PDF。</p><p>改进后的预览功能，可以添加标注、裁剪视频、宣传图片。</p><p>改进后 Safari 隐藏了 Facebook 这类在网页中的评论 / 喜欢插件，防止用户被广告追踪。</p><p>改版后的 App Store 好看了很多，苹果很可能重新重视这方面的建设。</p><img src="/2018/06/06/121727/10.png"><p><strong>开发者看点：</strong> </p><ul><li>黑化版的 Xcode 方便你加班到半夜也不刺眼 :D。</li><li>电脑与手机的无缝调用应用的功能。</li><li>Mac 应用的权限申请需要注意。</li><li>Mac 应用的开发可能将迎来一个小高潮。</li></ul><h1 id="watchOS"><a href="#watchOS" class="headerlink" title="watchOS"></a>watchOS</h1><p>健康与健身：支持好友间比赛（类似于 <strong>微信步数</strong> ）</p><p>连接：支持对讲机、Shortcuts、浏览网页、播放 Podcasts</p><h1 id="tvOS"><a href="#tvOS" class="headerlink" title="tvOS"></a>tvOS</h1><p>支持 4K HDR；支持杜比音效（DOLBY ATMOS）</p>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> AR </tag>
            
            <tag> 开发 </tag>
            
            <tag> wwdc 2018 </tag>
            
            <tag> macOS </tag>
            
            <tag> Siri </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>详解UIView之容器视图与控件</title>
      <link href="/2018/05/21/222410/"/>
      <url>/2018/05/21/222410/</url>
      <content type="html"><![CDATA[<p>UIKit 作为 iOS 开发中最常用也最重要的框架，不得不花些时间细细琢磨。而其中的UIView负责呈现应用内容和与内容的交互。</p><p>视图和控件是与应用 UI 的视觉模块。使用它们来绘制和组织应用内容在屏幕上的显示。</p><p>视图的作用：</p><ul><li>作为其他视图的父容器</li><li>响应触摸和其他手势操作</li><li>使用 Core Graphics 或 UIKit 类绘制自定义的内容</li><li>支持拖拽操作</li><li>响应焦点改变</li><li>为视图的尺寸，位置，外观属性添加动画</li></ul><p><strong>UIView</strong> 是所有视图的根类，并且定义了通用的行为。</p><p><strong>UIControl</strong> 定义了额外的行为来响应用户交互，它也是继承自 UIView 的。</p><p>两篇文章将介绍 UIView 和它的子类们。这次先详细解析下<strong>容器视图</strong>和<strong>控件</strong>。</p><h1 id="视图容器"><a href="#视图容器" class="headerlink" title="视图容器"></a>视图容器</h1><h2 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h2><p>UIStackView 是 iOS 9 引入的视图容器，可直接从 Object library 里拖到 storyboard 上使用。将一组子视图布局到一行或一列上，能动态地适应设备旋转、屏幕大小、可用空间的改变。只要定义了 StackView 的位置和尺寸（可选），它会自动调整子视图的布局和尺寸。</p><center><img src="/2018/05/21/222410/01_stackView.jpg"></center><p>UIStackView 有四个重要的属性：axis、alignment、distribution、spacing</p><ol><li>axis</li></ol><pre><code class="swift">public enum UILayoutConstraintAxis : Int {    case horizontal // 水平排列子视图    case vertical // 竖直排列子视图}</code></pre><ol start="2"><li>alignment</li></ol><pre><code class="swift">public enum UIStackViewAlignment : Int {    // 适用于竖直、水平方向    case fill // 子视图填充满 StackView    case center // 子视图居中对齐    // 仅适用于竖直 axis    case leading // 子视图左对齐    case trailing // 子视图右对齐    // 仅适用于水平 axis    public static var top: UIStackViewAlignment { get } // 子视图与 StackView 顶部对齐    public static var bottom: UIStackViewAlignment { get } // 子视图与 StackView 底部对齐    case firstBaseline // 对齐第一个子视图顶部    case lastBaseline // 对齐最后一个子视图底部}</code></pre><ol start="3"><li>distribution</li></ol><pre><code class="swift">public enum UIStackViewDistribution : Int {    /* 轴方向上填充子视图 (默认属性)      有一个子视图时，子视图轴方向尺寸填满 StackView     有多个优先级相同子视图时，拉伸其中一个子视图，填满 StackView     有多个优先级不同子视图时，按优先级从高到低设置子视图尺寸，最后被设置的子视图可能被拉伸或压缩    */    case fill // (默认属性)    /* 轴方向上，子视图尺寸相同     如在水平方向上，多个子视图宽度相同     */    case fillEqually    // 轴方向上，子视图尺寸按原先比例，拉伸或压缩    case fillProportionally    /* 轴方向上，子视图之间的间距相同     保持子视图原有尺寸，剩下的间距空间均分     */    case equalSpacing    // 轴方向上，子视图中心点间距离相同    case equalCentering}</code></pre><ol start="4"><li>spacing</li></ol><p>设置 distribution 为其前三个属性时，子视图之间没有间距，可以用 spacing 属性设置。</p><h2 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h2><p>滚动视图使得它所包含的内容视图可以滚动和缩放。它是 UITableView、UICollectionView、UITextView 的父类。</p><p>滚动视图只绘制其水平或竖直滚动条。</p><ol><li>滚动功能</li></ol><p>滚动视图需要知道内容视图的尺寸来判断什么时候停止滚动；当滚动超出内容的边界，它会自动弹回边界内。</p><pre><code class="swift">    open var contentOffset: CGPoint // 设置内容滚动的位置    open var contentSize: CGSize // 设置可以滚动的范围，一般为子视图的尺寸    open var contentInset: UIEdgeInsets // 给滚动内容四周增加滚动的范围    weak open var delegate: UIScrollViewDelegate? // 滚动委托    open var bounces: Bool // 默认为 true。设置 true，当滚动出边界时，有弹回来的弹簧效果    open var alwaysBounceVertical: Bool // 默认为 false。设置为 true，总是有弹簧效果（下拉刷新）    open var alwaysBounceHorizontal: Bool // 默认为 false。设置为 true，总是有弹簧效果    open var isPagingEnabled: Bool // 默认为 false。设置分页效果    open var isScrollEnabled: Bool // 默认为 true。可选择临时关闭滚动    open var isDirectionalLockEnabled: Bool // 默认为 false。设置true可以限制仅水平或竖直滚动    open var showsHorizontalScrollIndicator: Bool // 默认为 true。设置是否显示水平滚动条    open var showsVerticalScrollIndicator: Bool // 默认为 true。设置是否显示竖直滚动条    open var scrollIndicatorInsets: UIEdgeInsets // 默认为 0。调节指示器距离边缘的距离    open var indicatorStyle: UIScrollViewIndicatorStyle // 默认是黑色填充 + 白色边框，适合任何背景。还可设置纯黑、纯白    open var decelerationRate: CGFloat // 设置滚动的减速速度    open var indexDisplayMode: UIScrollViewIndexDisplayMode // 在 Apple tv 上使用的索引显示模式    open var isTracking: Bool { get } // 监控目标是否正在被追踪    open var isDragging: Bool { get } // 监控目标是否正在被拖拽    open var isDecelerating: Bool { get } // 监控目标是否正在减速    open var delaysContentTouches: Bool // 默认为 true。控制是否延时调用开始滚动的方法    open var canCancelContentTouches: Bool // 默认为 true。控制是否取消 touch 事件</code></pre><ol start="2"><li>缩放功能</li></ol><p>为了实现缩放，需要继承 <code>UIScrollViewDelegate</code> 协议，实现 <code>viewForZooming(in:)</code> 方法返回被缩放的视图，并且最大和最小缩放因子不能相同。</p><pre><code class="swift">    open var minimumZoomScale: CGFloat // 默认为 1.0    open var maximumZoomScale: CGFloat // 默认为 1.0。若要实现缩放，必须大于 minimumZoomScale    open var zoomScale: CGFloat // 默认为 1.0。设置缩放变化比例    open var bouncesZoom: Bool // 默认为 true。控制缩放的时候是否会反弹    open var isZooming: Bool { get } // 判断控件是否正在缩放    open var isZoomBouncing: Bool { get } // 判断控件是否正在缩放反弹</code></pre><ol start="3"><li>其他功能</li></ol><pre><code class="swift">    open var scrollsToTop: Bool // 点击屏幕状态栏回到页面顶部    open var keyboardDismissMode: UIScrollViewKeyboardDismissMode // 与输入框相关。可设置拖动时收起键盘，也可设置拖动停止时恢复键盘    @available(iOS 10.0, *)    open var refreshControl: UIRefreshControl? // 自带刷新按钮，下拉即可出现刷新控件</code></pre><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>表视图用于展示多行数据到一个列表中。</p><p>表视图可以有零个或多个区域（section），拥有各自的行（row）。任何区域都可以拥有自己的区域页头（section header）和区域页脚（section footer）。</p><p>表视图有 plain 和 grouped 两种样式。前者可以设置从 A 到 Z 的快速索引，放置在列表的右侧。</p><center><img src="/2018/05/21/222410/02_tableView.jpg"></center><p>使用表视图，必须包含数据源和委托。前者需要继承 UITableViewDataSource 协议，提供添加、删除、重排序所需要的数据模型；后者需要继承 UITableViewDelegate 协议，处理选中、重排序、高亮、编辑操作。</p><ol><li>表视图数据源和外观</li></ol><pre><code class="swift">    open var style: UITableViewStyle { get }    weak open var dataSource: UITableViewDataSource? // 数据源    weak open var delegate: UITableViewDelegate? // 委托    @available(iOS 10.0, *)    weak open var prefetchDataSource: UITableViewDataSourcePrefetching? // 在 cell 渲染在屏幕之前，提前获取数据     /*     用于 iPad，将文件从一个应用拖到其他应用    */    @available(iOS 11.0, *)    weak open var dragDelegate: UITableViewDragDelegate?    @available(iOS 11.0, *)    weak open var dropDelegate: UITableViewDropDelegate?    open var rowHeight: CGFloat // 行高    open var sectionHeaderHeight: CGFloat // 区域页头高度    open var sectionFooterHeight: CGFloat // 区域页脚高度    open var estimatedRowHeight: CGFloat // 估算行高    open var estimatedSectionHeaderHeight: CGFloat // 估算区域页头高度    open var estimatedSectionFooterHeight: CGFloat // 估算区域页脚高度    open var separatorInset: UIEdgeInsets // 自定义 cell 分割线的尺寸。    open var separatorInsetReference: UITableViewSeparatorInsetReference // 设置 separatorInset 属性的参照值    @available(iOS 3.2, *)    open var backgroundView: UIView? // 背景视图</code></pre><ol start="2"><li>信息</li></ol><pre><code class="swift">    open var numberOfSections: Int { get } // 有多少区域    open var visibleCells: [UITableViewCell] { get } // 在屏幕上可见的单元格    open var indexPathsForVisibleRows: [IndexPath]? { get } // 可见单元格的 IndexPath</code></pre><ol start="3"><li>编辑和选中</li></ol><pre><code class="swift">    open var isEditing: Bool // 默认是false    open var allowsSelection: Bool // 设置单元格是否可选    open var allowsSelectionDuringEditing: Bool // 默认是false，设置编辑模式下，单元格是否可选    open var allowsMultipleSelection: Bool // 设置单元格是否可多选    open var allowsMultipleSelectionDuringEditing: Bool // 设置在编辑模式下，单元格是否可多选    open var indexPathForSelectedRow: IndexPath? { get } // 获取对应的 IndexPath 或 nil    open var indexPathsForSelectedRows: [IndexPath]? { get } // 获取对应的多个 IndexPath 或 nil</code></pre><ol start="4"><li>外观</li></ol><pre><code class="swift">    open var sectionIndexMinimumDisplayRowCount: Int // 设置该 section 有多少行单元格才显示索引    open var sectionIndexColor: UIColor? // 索引的字体颜色    open var sectionIndexBackgroundColor: UIColor? // 索引的背景颜色    open var sectionIndexTrackingBackgroundColor: UIColor? // 索引被触摸时候的背景颜色    open var separatorStyle: UITableViewCellSeparatorStyle // 分割线样式    open var separatorColor: UIColor? // 分割线颜色    @NSCopying open var separatorEffect: UIVisualEffect? // 分割线视觉效果    open var cellLayoutMarginsFollowReadableWidth: Bool // 针对 iPad，不设置会导致左侧边距很大    @available(iOS 11.0, *)    open var insetsContentViewsToSafeArea: Bool // 默认为true，设置 iPhone X 安全区域    open var tableHeaderView: UIView? // 表页头视图    open var tableFooterView: UIView? // 表页脚视图</code></pre><h3 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h3><p>使用自定义布局，管理和呈现一组有序的数据集合。</p><p>集合视图从继承了 UICollectionViewDataSource Protocol 协议的对象中获取数据，每一条数据就是一个最小的独立的单元，可以把多个单元编组。集合视图在屏幕上呈现单元，每一个单元都是 UICollectionViewCell 的实例。</p><center><img src="/2018/05/21/222410/03_collectionView.png"></center><p>集合视图与布局对象：</p><p>布局对象是 UICollectionViewLayout 类的子类，负责定义单元和页头/页脚的组织和位置的信息，由集合视图处理这些信息。</p><ol><li>集合视图数据源</li></ol><pre><code class="swift">    open var collectionViewLayout: UICollectionViewLayout // 布局对象    weak open var dataSource: UICollectionViewDataSource? // 数据源    weak open var delegate: UICollectionViewDelegate? // 操作委托    @available(iOS 10.0, *)    weak open var prefetchDataSource: UICollectionViewDataSourcePrefetching? //在 cell 渲染在屏幕之前，提前获取数据    open var isPrefetchingEnabled: Bool //设置提前渲染，是否可用    // 用于 iPad，处理拖拽    @available(iOS 11.0, *)    weak open var dragDelegate: UICollectionViewDragDelegate?    weak open var dropDelegate: UICollectionViewDropDelegate?    open var dragInteractionEnabled: Bool // 在 iPhone 上默认是false，可开启。    open var reorderingCadence: UICollectionViewReorderingCadence // 调节集合视图重排序的响应性    open var backgroundView: UIView? // 作为单元和页头/页脚视图的背景视图</code></pre><ol start="2"><li>信息</li></ol><pre><code class="swift">    open var numberOfSections: Int { get } // 有多少区域    open var visibleCells: [UICollectionViewCell] { get } // 有多少屏幕上可见的单元    open var indexPathsForVisibleItems: [IndexPath] { get } // 可见的单元对应的 IndexPath</code></pre><ol start="3"><li>编辑</li></ol><pre><code class="swift">    open var allowsSelection: Bool // 默认可选    open var allowsMultipleSelection: Bool // 默认不可多选    open var indexPathsForSelectedItems: [IndexPath]? { get } // 返回选中的 IndexPath 或 nil    @available(iOS 11.0, *)    open var hasUncommittedUpdates: Bool { get } // 判断当前集合视图是否存在 placeholder</code></pre><h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>UIControl 类是控件的基类，在响应用户的交互时的动作或意图。</p><p>控件使用 Target-Action 机制向应用报告用户的交互，三种形式如下：</p><pre><code class="swift">@IBAction func doSomething()@IBAction func doSomething(sender: UIButton)@IBAction func doSomething(sender: UIButton, forEvent event: UIEvent)</code></pre><p>基本属性</p><pre><code class="swift">    open var isEnabled: Bool // 默认为可用    open var isSelected: Bool // 默认不可选    open var isHighlighted: Bool // 默认非高亮状态    open var contentVerticalAlignment: UIControlContentVerticalAlignment // 默认控件内的内容竖直居中对齐    open var contentHorizontalAlignment: UIControlContentHorizontalAlignment // 默认控件内的内容水平居中对齐    open var state: UIControlState { get } // 可能处于多个状态 (e.g. disabled|selected).     open var isTracking: Bool { get } // 是否正在追踪触控操作    open var isTouchInside: Bool { get } // 正在追踪触控操作时可用</code></pre><h3 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h3><p>在用户交互时，用于执行你的自定义代码的控件。</p><p>按钮有五个状态：default、highlighted、focused、selected、disabled。</p><p>按钮组成：标题字符串、图片、背景图片。使用按钮的titleLabel、imageView、backgroundImage 属性操作。</p><center><img src="/2018/05/21/222410/04_button.png"></center><ol><li>属性</li></ol><pre><code class="swift">    open var contentEdgeInsets: UIEdgeInsets // 设置内边距，默认为 UIEdgeInsetsZero    open var titleEdgeInsets: UIEdgeInsets // 设置标题内边距，默认为 UIEdgeInsetsZero    open var imageEdgeInsets: UIEdgeInsets // 设置图片内边距，默认为 UIEdgeInsetsZero    open var reversesTitleShadowWhenHighlighted: Bool // 高亮时，切换阴影雕刻或凸印效果，默认为false    open var adjustsImageWhenHighlighted: Bool // 高亮时，图片颜色是否变深，默认为 true    open var adjustsImageWhenDisabled: Bool // 不可用时，图片颜色是否变浅，默认为 true    open var showsTouchWhenHighlighted: Bool // 高亮时，按钮是否变化，默认为 false    open var tintColor: UIColor! // 按钮文字颜色    open var buttonType: UIButtonType { get } // 获取按钮类型    open var currentTitle: String? { get } // 获取当前标题    open var currentTitleColor: UIColor { get } // 获取当前标题颜色    open var currentTitleShadowColor: UIColor? { get } // 获取当前标题阴影颜色    open var currentImage: UIImage? { get } // 获取当前图片    open var currentBackgroundImage: UIImage? { get } // 获取当前背景图    open var currentAttributedTitle: NSAttributedString? { get } // 获取当前标题特征    open var titleLabel: UILabel? { get } // 获取当前标题标签    open var imageView: UIImageView? { get } // 获取当前图片视图</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    open func setTitle(_ title: String?, for state: UIControlState) // 设置某状态下的标题    open func setTitleColor(_ color: UIColor?, for state: UIControlState) // 设置某状态下的标题颜色    open func setTitleShadowColor(_ color: UIColor?, for state: UIControlState) // 设置某状态下的标题阴影颜色    open func setImage(_ image: UIImage?, for state: UIControlState) // 设置某状态下的图片    open func setBackgroundImage(_ image: UIImage?, for state: UIControlState) // 设置某状态下的背景图    open func setAttributedTitle(_ title: NSAttributedString?, for state: UIControlState) // 设置某状态下的标题特征，默认为 nil，即单行    open func title(for state: UIControlState) -&gt; String? // 获取某状态下的标题    open func titleColor(for state: UIControlState) -&gt; UIColor? // 获取某状态下的标题颜色    open func titleShadowColor(for state: UIControlState) -&gt; UIColor? // 获取某状态下的标题阴影颜色    open func image(for state: UIControlState) -&gt; UIImage? // 获取某状态下的图片    open func backgroundImage(for state: UIControlState) -&gt; UIImage? // 获取某状态下的背景图    open func attributedTitle(for state: UIControlState) -&gt; NSAttributedString? // 获取某状态下的标题特征    open func backgroundRect(forBounds bounds: CGRect) -&gt; CGRect // 获取背景尺寸    open func contentRect(forBounds bounds: CGRect) -&gt; CGRect // 获取内容尺寸    open func titleRect(forContentRect contentRect: CGRect) -&gt; CGRect // 获取标题尺寸    open func imageRect(forContentRect contentRect: CGRect) -&gt; CGRect // 获取图片尺寸</code></pre><h3 id="UIDatePicker"><a href="#UIDatePicker" class="headerlink" title="UIDatePicker"></a>UIDatePicker</h3><p>用来输入日期和时间的控件。</p><center><img src="/2018/05/21/222410/05_datePicker.png"></center><ol><li>属性</li></ol><pre><code class="swift">    open var datePickerMode: UIDatePickerMode // 显示样式，可设置为 dateAndTime(默认)、date、time、countDownTimer    open var locale: Locale? // 本地化设置，默认为用户设备当前设置的地区 Locale.current。设置为 nil 返回系统默认的    open var calendar: Calendar! // 日历设置，默认为 Calendar.current。设置为 nil 返回系统默认的    open var timeZone: TimeZone? // 时区设置，默认为 nil。 使用当前时区或日历中的时区    open var date: Date // 默认为选择器创建时候的日期。在倒计时模式中忽略该属性    // 限制可选的最早/最晚日期，默认为 nil。在倒计时模式中忽略该属性    open var minimumDate: Date?     open var maximumDate: Date?     open var countDownDuration: TimeInterval // 仅在倒计时模式中生效，以秒为单位。默认为 0.0，最大为 23:59。    open var minuteInterval: Int // 分钟滚轮的两个档之间间隔分钟数。必须刚好被 60 整除，默认为 1，最小为 1，最大为 30</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    open func setDate(_ date: Date, animated: Bool) // 如果 animated 为 true，启动动画并设置该日期</code></pre><h3 id="UIPageControl"><a href="#UIPageControl" class="headerlink" title="UIPageControl"></a>UIPageControl</h3><p>在水平方向显示一组圆点，每一个点代表一个页面，可参考 iPhone自带的天气应用。</p><p>一般与 UIScrollView 和 UIScrollViewDelegate 的 scrollViewDidScroll(_ scrollView: UIScrollView)  方法一起用</p><center><img src="/2018/05/21/222410/06_pagecontrol.jpg"></center><ol><li>属性</li></ol><pre><code class="swift">    open var numberOfPages: Int // 总页数，默认为 0    open var currentPage: Int // 当前第几页，默认为 0，值为从 0 到 n - 1 (n 为总页数)    open var hidesForSinglePage: Bool // 当只有一页时，隐藏翻页指示符，默认为 false    open var defersCurrentPageDisplay: Bool // 设置以后，点击时不会改变控制器显示的当前页码，必须手动调用 updateCurrentPageDisplay 方法以后才会更新，默认为 false    open var pageIndicatorTintColor: UIColor? // 翻页指示符颜色    open var currentPageIndicatorTintColor: UIColor? // 当前翻页指示符颜色</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    open func updateCurrentPageDisplay() // 更新展示页面与当前页面匹配。如果 defersCurrentPageDisplay 为 false，忽略此方法。直接设置页面值会立刻更新    open func size(forNumberOfPages pageCount: Int) -&gt; CGSize</code></pre><h3 id="UISegmentedControl"><a href="#UISegmentedControl" class="headerlink" title="UISegmentedControl"></a>UISegmentedControl</h3><p>一个有多段组成的水平控件，每一段相当于一个独立按钮。</p><center><img src="/2018/05/21/222410/07_segmentedcontrol.jpg"></center><ol><li>属性</li></ol><pre><code class="swift">    public init(items: [Any]?) // items 可以是字符串或者图片，控件自动适应内容大小    open var isMomentary: Bool // 设置后，不再显示选中状态。默认为 false    open var numberOfSegments: Int { get } // 返回 items 的数量    open var apportionsSegmentWidthsByContent: Bool // 如果设置了控件的宽度为 0，把这个属性设为 true 使得控件宽度根据内容宽度自适应，默认为 false    open var selectedSegmentIndex: Int // 选中的分段（segment）索引    open var tintColor: UIColor! // 设置边框和选中颜色。继承自 UIView</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    open func insertSegment(withTitle title: String?, at segment: Int, animated: Bool) // 插入新的标题分段到指定的索引位置    open func insertSegment(with image: UIImage?, at segment: Int, animated: Bool) // 插入新的图片分段到指定的索引位置    open func removeSegment(at segment: Int, animated: Bool) // 移除指定索引位置的分段    open func removeAllSegments() // 移除所有分段    open func setTitle(_ title: String?, forSegmentAt segment: Int) // 设置指定索引位置的分段标题    open func titleForSegment(at segment: Int) -&gt; String? // 获取指定索引位置的分段标题    open func setImage(_ image: UIImage?, forSegmentAt segment: Int) // 设置指定索引位置的分段图片    open func imageForSegment(at segment: Int) -&gt; UIImage? // 获取指定索引位置的分段标题    open func setWidth(_ width: CGFloat, forSegmentAt segment: Int) // 设置分段宽度，默认为 0.0，自动适应大小    open func widthForSegment(at segment: Int) -&gt; CGFloat // 获取分段宽度    open func setContentOffset(_ offset: CGSize, forSegmentAt segment: Int) // 调整分段内部的图片或文本位置，默认为 (0,0)    open func contentOffsetForSegment(at segment: Int) -&gt; CGSize // 获取分段内部图片或文本的位置    open func setEnabled(_ enabled: Bool, forSegmentAt segment: Int) // 默认为 true，可用    open func isEnabledForSegment(at segment: Int) -&gt; Bool // 设置指定索引位置的分段是否可用    open func setBackgroundImage(_ backgroundImage: UIImage?, for state: UIControlState, barMetrics: UIBarMetrics) // 设置控件在某状态下的背景图片    open func backgroundImage(for state: UIControlState, barMetrics: UIBarMetrics) -&gt; UIImage?// 获取控件在某状态下的背景图片    /* 如果需要自定义分段控件的外观，需要提供三种情况的分段分割图片：左和右都未选中之间的分隔图片，左选中和右边之间的分隔图片，左和右选中之间的分隔图片。     */    open func setDividerImage(_ dividerImage: UIImage?, forLeftSegmentState leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics)    open func dividerImage(forLeftSegmentState leftState: UIControlState, rightSegmentState rightState: UIControlState, barMetrics: UIBarMetrics) -&gt; UIImage?    // 设置和获取字体、文字颜色、标题阴影    open func setTitleTextAttributes(_ attributes: [AnyHashable : Any]?, for state: UIControlState)    open func titleTextAttributes(for state: UIControlState) -&gt; [AnyHashable : Any]?    // 设置和获取标题或图片的位置    open func setContentPositionAdjustment(_ adjustment: UIOffset, forSegmentType leftCenterRightOrAlone: UISegmentedControlSegment, barMetrics: UIBarMetrics)    open func contentPositionAdjustment(forSegmentType leftCenterRightOrAlone: UISegmentedControlSegment, barMetrics: UIBarMetrics) -&gt; UIOffset</code></pre><h3 id="UISlider"><a href="#UISlider" class="headerlink" title="UISlider"></a>UISlider</h3><p>用于从一个连续的范围值中选取一个值。</p><center><img src="/2018/05/21/222410/08_slider.png"></center><ol><li>属性</li></ol><pre><code class="swift">    open var value: Float // 设置当前值，默认为 0.0    open var minimumValue: Float // 设置最小值，默认为 0.0    open var maximumValue: Float // 设置最大值，默认为 1.0    open var minimumValueImage: UIImage? // 设置最小值那一端的图片，默认为 nil    open var maximumValueImage: UIImage? // 设置最大值那一端的图片，默认为 nil    open var isContinuous: Bool // 设置是否每次数值改变就收到事件，默认为 true    open var minimumTrackTintColor: UIColor? // 滑块到最小值之间的填充颜色    open var maximumTrackTintColor: UIColor? // 滑块到最大值之间的填充颜色    open var thumbTintColor: UIColor? // 滑块的填充颜色</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    open func setValue(_ value: Float, animated: Bool) // 设置滑块的值，但不会出发 UISlider 值改变事件    open func setThumbImage(_ image: UIImage?, for state: UIControlState) // 设置某状态下的滑块图片    open func setMinimumTrackImage(_ image: UIImage?, for state: UIControlState) // 设置某状态下的最小值那一端的图片    open func setMaximumTrackImage(_ image: UIImage?, for state: UIControlState) // 设置某状态下的最大值那一端的图片    open func thumbImage(for state: UIControlState) -&gt; UIImage? // 设置/获取某状态下的滑块图片    open func minimumTrackImage(for state: UIControlState) -&gt; UIImage? // 设置/获取某状态下的最小值那一端的图片    open func maximumTrackImage(for state: UIControlState) -&gt; UIImage? // 设置/获取某状态下的最大值那一端的图片    open var currentThumbImage: UIImage? { get } // 获取滑块图片    open var currentMinimumTrackImage: UIImage? { get } // 获取最小值那一端的图片    open var currentMaximumTrackImage: UIImage? { get } // 获取最大值那一端的图片    // lets a subclass lay out the track and thumb as needed    open func minimumValueImageRect(forBounds bounds: CGRect) -&gt; CGRect // 返回最小值那一端的图片大小    open func maximumValueImageRect(forBounds bounds: CGRect) -&gt; CGRect // 返回最大值那一端的图片大小    open func trackRect(forBounds bounds: CGRect) -&gt; CGRect // 返回滑道大小    open func thumbRect(forBounds bounds: CGRect, trackRect rect: CGRect, value: Float) -&gt; CGRect // 返回滑块大小</code></pre><h3 id="UIStepper"><a href="#UIStepper" class="headerlink" title="UIStepper"></a>UIStepper</h3><p>微调器用于增加或减少一个值。</p><center><img src="/2018/05/21/222410/09_stepper.jpg"></center><ol><li>属性</li></ol><pre><code class="swift">    open var isContinuous: Bool // 设置是否每次数值改变就收到事件，默认为 true    open var autorepeat: Bool // 是指是否按住不放就改变数值，按得越久数值变化越快，默认为 ture    open var wraps: Bool // 是否把数值限制在最大和最小范围内。若设置 true，超过最大值会自动变为最小值，默认为 false    open var value: Double // 控件的数值    open var minimumValue: Double // 控件最小值，必须比最大值小，默认值为 0    open var maximumValue: Double // 控件最大值，必须必最小值大，默认值为 1000    open var stepValue: Double // 每次变化的大小，必须大于 0，默认为 1    open var tintColor: UIColor! // 控件的颜色</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">     // 设置或获取某状态的背景图    open func setBackgroundImage(_ image: UIImage?, for state: UIControlState)    open func backgroundImage(for state: UIControlState) -&gt; UIImage?    // 设置或获取左边某状态，右边某状态的分割图片    open func setDividerImage(_ image: UIImage?, forLeftSegmentState leftState: UIControlState, rightSegmentState rightState: UIControlState)    open func dividerImage(forLeftSegmentState state: UIControlState, rightSegmentState state: UIControlState) -&gt; UIImage?    // 设置或获取 + 的图片    open func setIncrementImage(_ image: UIImage?, for state: UIControlState)    open func incrementImage(for state: UIControlState) -&gt; UIImage?    // 设置或获取 - 的图片    open func setDecrementImage(_ image: UIImage?, for state: UIControlState)    open func decrementImage(for state: UIControlState) -&gt; UIImage?</code></pre><h3 id="UISwitch"><a href="#UISwitch" class="headerlink" title="UISwitch"></a>UISwitch</h3><p>开关用于提供二选一的选项。</p><center><img src="/2018/05/21/222410/10_switch.png"></center><ol><li>属性</li></ol><pre><code class="swift">    open var onTintColor: UIColor? // 设置开启状态的填充颜色    open var tintColor: UIColor! // 设置关闭状态的边框颜色    open var thumbTintColor: UIColor? // 设置开关圆点的颜色    // 设置开启/关闭状态的图片(iOS 7 之后无效)    open var onImage: UIImage?    open var offImage: UIImage?    open var isOn: Bool // 是否打开</code></pre><ol start="2"><li>方法</li></ol><pre><code class="swift">    // 初始化    public init(frame: CGRect)    public init?(coder aDecoder: NSCoder)    // 设置开关状态，不会引起状态改变事件    open func setOn(_ on: Bool, animated: Bool)</code></pre>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UIKit </tag>
            
            <tag> UIScrollView </tag>
            
            <tag> UIControl </tag>
            
            <tag> UIView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>管理iOS应用的生命周期</title>
      <link href="/2018/05/17/205301/"/>
      <url>/2018/05/17/205301/</url>
      <content type="html"><![CDATA[<p>本篇文章帮助理解iOS应用生命周期，和如何通过应用委托（app delegate）管理应用的上层行为。</p><p>UIKit应用总是处于以下五个状态之一：</p><ul><li>未运行状态（Not Running ）：应用未启动，或者已被系统终止。</li><li>不活跃状态（Inactive）：应用刚启动，进入活跃状态前的短暂状态。</li><li>活跃状态（Active）：应用正在屏幕上运行，接收事件。处于这个状态时的应用也被称为前台应用。</li><li>后台状态（Background）：应用在后台运行，还可以执行代码。</li><li>挂起状态（Suspend）：应用在后台，已停止运行代码。收到系统内存警告时，系统将终止处于此状态的应用。</li></ul><div align="center"><br><br><img src="/2018/05/17/205301/01_app_life_circle.png"><br><br></div><h1 id="管理生命周期事件"><a href="#管理生命周期事件" class="headerlink" title="管理生命周期事件"></a>管理生命周期事件</h1><p>当应用从一个状态过渡到另一个状态的时候，UIKit通知应用的应用委托对象（ 即一个遵守了<strong>UIApplicationDelegate</strong> 协议的对象，通常是创建项目时自带的AppDelegate.swift文件）。使用应用委托调整应用行为到对应的最新状态。</p><p>系统会通知应用委托以下过渡：</p><h2 id="启动（Launch）"><a href="#启动（Launch）" class="headerlink" title="启动（Launch）"></a>启动（Launch）</h2><p>应用从未运行状态过渡到不活跃，或者过渡到后台状态。为应用的运行做准备。</p><p>应用会自动初始化视图和视图控制器，开启应用的主事件循环（loop）。</p><p>使用<code>application(_:willFinishLaunchingWithOptions:)</code> 初始化数据结构；执行只需配置一次的任务。</p><p>使用<code>application(_:didFinishLaunchingWithOptions:)</code> 校验内容；更新应用的默认UI；开始连接网络等任务。</p><h2 id="活化（Activation）"><a href="#活化（Activation）" class="headerlink" title="活化（Activation）"></a>活化（Activation）</h2><p>应用从不活跃状态过渡到活跃状态。为应用在前台运行和在屏幕可见时做准备。</p><p>应用刚启动时，系统调用应用委托的<code>applicationDidBecomeActive(_:)</code> 方法告诉你应用处于活跃状态；</p><p>应用已经在后台运行，系统会先调用<code>applicationWillEnterForeground(_:)</code> 方法，再调用<code>applicationDidBecomeActive(_:)</code> 方法。</p><p>可以开始或恢复用来执行任务的线程队列；改变UI；开启定时器。</p><p>系统随后通知视图控制器的<code>viewWillAppear(_:)</code> 方法时，用以更新视图内容；</p><p>系统随后通知视图控制器的<code>viewDidAppear(_:)</code> 方法时，用以开启动画；开始设置为自动播放的媒体文件；开始以全帧率更新游戏或沉浸式内容。</p><h2 id="钝化（Deactivation）"><a href="#钝化（Deactivation）" class="headerlink" title="钝化（Deactivation）"></a>钝化（Deactivation）</h2><p>在应用从前台过渡到后台前，从活跃状态过渡到不活跃状态，短暂或长时间使应用静音。</p><p>系统调用 <code>applicationWillResignActive(_:)</code> ，用以保存用户数据到磁盘并关闭打开的文件；只执行对于保存用户数据至关重要的任务；停止计时器；暂停游戏。</p><h2 id="后台执行（Background-execution）"><a href="#后台执行（Background-execution）" class="headerlink" title="后台执行（Background execution）"></a>后台执行（Background execution）</h2><p>当用户切换到其他应用，或者回到桌面时，应用过渡到后台状态。只用来处理与界面无关的重要任务。</p><p>系统调用<code>applicationDidEnterBackground(_:)</code> 用以清理应用的UI（如隐藏敏感数据、取消弹窗和其他临时界面）；取消注册Bonjour并关闭socket通信；释放图片、媒体文件、临时对象。</p><h2 id="终止（Termination）"><a href="#终止（Termination）" class="headerlink" title="终止（Termination）"></a>终止（Termination）</h2><p>应用会从任何状态过渡到未运行状态。（例外：被挂起的应用被终止时，不会收到通知）。用来取消所有任务并准备退出。</p><p>系统调用<code>applicationWillTerminate(_ application: UIApplication)</code> 大概有5秒的时间，用以执行最终的清理任务，如释放共享资源，保存用户数据，停止计时器。</p><h1 id="管理行为事件"><a href="#管理行为事件" class="headerlink" title="管理行为事件"></a>管理行为事件</h1><p>应用委托也响应其他重要的事件：</p><ul><li>内存警告：减少应用使用的内存</li><li>时间改变：更新应用中与时间紧密相关的功能</li><li>受保护的数据变为可用/不可用：当用户锁屏/解锁设备的时候，管理文件</li><li>状态恢复：恢复应用UI为用户离开应用时的状态，表现的像是应用一直在运行。</li><li>无缝转接任务：换在其他设备上继续当前任务</li><li>开放链接：接收并打开收到的URL</li><li>应用间通信：从已配对的手表应用中接收数据</li><li>文件下载：使用<strong>URLSession</strong>对象接收应用下载的文件</li></ul><p>虽然大部分的应用生命周期事件都在应用委托中处理，但也可以在其他地方处理。大部分的事件，UIKit也会生成可被监听的通知。具体的可被监听的通知列表见<a href="https://developer.apple.com/documentation/uikit/uiapplication" target="_blank" rel="noopener">UIApplication</a>；更多关于处理事件的方法见<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate" target="_blank" rel="noopener">UIApplicationDelegate</a>。</p>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> 应用委托 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品设计从0到1 - 《用户体验要素》</title>
      <link href="/2018/05/16/171346/"/>
      <url>/2018/05/16/171346/</url>
      <content type="html"><![CDATA[<p>用户体验要素提供了基本框架，让你从这五个层面上思考，从关注抽象的产品目标，到执着于表现层的细节。</p><img src="/2018/05/16/171346/01_thumbnail.jpg"><h1 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h1><p>有的失败，从一开始就注定了，不是因为技术，不是因为用户体验，而是因为没有考虑过战略层的事情。如果不从大局考虑，没有方向，直接就招兵买马开始投入，也只是无头的苍蝇。比如一上来就想做个微信，这恐怕有99.99999….%的概率会失败。</p><h2 id="产品目标"><a href="#产品目标" class="headerlink" title="产品目标"></a>产品目标</h2><p>我们想要什么？</p><p>如果产品目标模糊，每个人头脑里想的目标也就不同，无法齐心协力，单点突破。</p><p>产品目标是产品需求的核心任务，或者说是商业诉求。</p><p>制定的产品目标，不要太广义，也不要太狭义。确定一个产品核心，确保公司每个人都清楚知道，统一战线。</p><h2 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h2><p>用户想要什么？</p><h3 id="用户细分"><a href="#用户细分" class="headerlink" title="用户细分"></a>用户细分</h3><p>要想知道用户的需求，就得先知道哪些人是我们的用户，采用的方法时<strong>用户细分</strong>。借用传统市场营销的<strong>人口统计特征</strong>方法，按性别、年龄、教育水平、婚姻状况、收入等方面分类。有时同一地区，教育水平相同的人，他们的世界观和兴趣点不一定也相同，就可以使用建立<strong>消费心态档案</strong>的方法，覆盖<strong>人口统计特征</strong>无法覆盖的部分，。</p><h3 id="可用性和用户研究"><a href="#可用性和用户研究" class="headerlink" title="可用性和用户研究"></a>可用性和用户研究</h3><p>可用性的目标在于寻找令产品更容易使用的途径。</p><p>用户研究的方向有：</p><ul><li>普遍行为研究：用于收集用户的普遍观点和感知。可使用市场调研方法（问卷调查、用户访谈、焦点小组）</li><li>具体行为研究：用于理解具体的用户行为，以及用户在与产品交互时的行为。可使用现场调查、用户测试（产品、原型）方法。</li></ul><h3 id="创建人物角色"><a href="#创建人物角色" class="headerlink" title="创建人物角色"></a>创建人物角色</h3><p>为了使有价值的数据被重视，可以创建一个人物角色，列出他的各种身份属性，一切实现围绕这个用户的需求来进行。此方法也叫做用户模型、用户简介。</p><p>确定产品的目标用户，找准用户的痛点，挖掘用户真实需求，投入资源，认真打磨产品。</p><p>比如要给用户提供休闲娱乐，展现自己才能，去大明星中心化的平台。通过前面的方法统计，确定目标用户身份属性后，建立人物角色。阿娇，今年24岁，大学毕业，白领，一线城市，性格外向，喜欢酷的东西，喜欢音乐，唱歌好听。</p><h1 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h1><p>产品应该提供给用户什么样的功能和形式？这阶段哪些该做，哪些不该做？</p><p>定义范围：</p><ul><li>过程：考虑潜在的冲突，产品的粗略实现。现在能解决哪些事情，哪些可以延后解决。</li><li>产品：明确这个项目要做的全部工作，集中资源去实现。</li></ul><h2 id="功能规格"><a href="#功能规格" class="headerlink" title="功能规格"></a>功能规格</h2><p>哪些应该作为产品的功能，以及功能的组合？</p><p>内容：</p><ul><li>包含设计和开发过程中可能混淆的功能定义。</li><li>不包含每一个细节、也不涉及产品愿景。</li></ul><p>撰写的规则：</p><ul><li>乐观。描述这个系统要做什么去“防止”不希望的事情发生，而不是描述系统“不应该”做什么。如把“系统不允许用户未登录的状态拍摄视频”，改为“未登录用户要拍摄视频时，系统引导用户登录”。</li><li>具体。详细地描述状况，决定某功能是否被实现。如把“推荐最受欢迎的视频”，改为“推荐观看数量，点赞数量按权重计算后排名高的视频”。</li><li>避免主观的语气。可以使需求“保持明确”，“避免歧义“。如“打造一个时尚的短视频平台”改为“打造符合产品定位的短视频平台”。</li></ul><h2 id="内容需求"><a href="#内容需求" class="headerlink" title="内容需求"></a>内容需求</h2><p>哪些信息必须纳入设计范围？</p><p>内容需求应该提供每一个特性规模的大致预估；</p><ul><li>文本字数、最大行数。</li><li>图片的原本尺寸大小，在界面中显示的尺寸大小。</li><li>下载文件大小。</li></ul><h2 id="需求优先级"><a href="#需求优先级" class="headerlink" title="需求优先级"></a>需求优先级</h2><p>战略目标与需求，通常是一对多，或者多对一的关系。</p><p>有时会因为技术局限、时间有限，而无法在现阶段实现所有的需求，这就需要安排需求的优先级。</p><h1 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h1><p>如何把分散的需求，组成一个有组织整体？</p><p>为产品建立一个概念结构。</p><p>功能型产品重交互设计；信息型产品重信息架构。</p><h2 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h2><p>为用户设计结构化体验。</p><p>关注于描述“可能的用户行为”，同时定义“系统如何配合与响应”这些用户行为。</p><p>用户在现实世界的客观对象或行为，抽象为某种信息结构，不依赖于特定的软件产品，称为<strong>概念模型</strong>。如用户第一次在电商网站看到”购物车”，不需要思考就知道把商品加入到购物车。</p><h2 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h2><p>选择并组织要传达的信息，保证其他参与者能理解并使用这些信息。</p><p>涉及组织管理、分类、顺序排列，以及与内容呈现有关的图书管理、新闻学、技术通信等学科。</p><p>对于用户，研究人们如何认知信息的过程；对于产品，关注呈现给用户的信息是否合理并具有意义。</p><h2 id="结构化内容"><a href="#结构化内容" class="headerlink" title="结构化内容"></a>结构化内容</h2><p>设计组织分类和导航的结构，让用户可以高效率，有效地浏览网站的内容。</p><p>建立分类体系的方法：</p><ul><li>从上到下。从战略层考虑，即根据产品目标和用户需求直接进行结构设计。</li><li>从下到上。从范围层考虑，根据“内容和功能需求的分析”设计。</li></ul><h2 id="结构方法"><a href="#结构方法" class="headerlink" title="结构方法"></a>结构方法</h2><p>信息结构的基本单位是<strong>节点</strong>。可以是小到数字，大到图书馆，我们将处理节点，而非页面、文档、组件。</p><p>常见类型：</p><ul><li>层级结构。也称树状结构、中心辐射结构，节点与其他节点之间的父级/子级节点。</li><li>矩阵结构。允许用户在节点与节点之间沿着两个或更多的维度移动。</li><li>自然结构。不遵循任何一致的模式，基本没有分类概念。</li><li>线性结构。来自于线下媒体，连贯的语言流程，是最基本的类型。</li></ul><h1 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h1><p>进一步提炼需求结构，确定详细的界面外观、导航和信息设计。</p><p>对于功能型产品，通过<strong>界面设计</strong>确定框架，如“按钮、输入框”；对于信息型产品，通过<strong>导航设计</strong>来呈现信息；而<strong>信息设计</strong>是两者都必须要做的，用于呈现有效的信息沟通。</p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>通过它，用户能接触到哪些“在结构层的交互设计中”确定的“具体功能”。</p><p>选择正确的界面元素。</p><p>成功的界面设计能让用户一眼看到“最重要的东西”，不重要的不应该被大多数用户注意到。</p><h2 id="导航设计"><a href="#导航设计" class="headerlink" title="导航设计"></a>导航设计</h2><p>通过它，用户可以“在结构中自由穿行”。</p><p>导航设计必须完成的目标：</p><ul><li>提供给用户一种在产品间跳转的方法。</li><li>传达出这些元素和它们所包含内容之间的关系。</li><li>传达出它的内容和用户当前浏览页面之间的关系。</li></ul><p>常见的导航系统：</p><ul><li>全局导航：提供用户最有可能需要从产品的最终页面到其他地方的一组关键点。比如网站顶部导航栏，App底部的Tabbar。</li><li>局部导航：提供给用户在这个架构中到直接上层，或直接下层结构的通路。</li><li>辅助导航：提供了全局导航和局部导航不能快速达到的相关内容的快捷途径。</li><li>上下文导航：或叫做“内联导航”，是嵌入页面自身内容的一种导航。</li><li>友好导航：提供给用户他们通常不会需要的连接，但它们是作为一种便利的途径来使用的。</li><li>网站地图：是一种常见的远程导航工具，给用户一个简明的、单页的网站整体结构的快捷浏览方式。</li><li>索引表：是按字母顺序排列的、链接到相关页面的列表。</li></ul><h2 id="信息设计"><a href="#信息设计" class="headerlink" title="信息设计"></a>信息设计</h2><p>界面设计和导航设计，都需要以“一个良好的信息设计的支持”为前提。</p><p>决定如何呈现这些信息，使人们能很容易使用或理解它们。</p><h2 id="线框图"><a href="#线框图" class="headerlink" title="线框图"></a>线框图</h2><p>页面布局将信息设计、界面设计和导航设计放在一起，形成统一的架构。于是页面布局被纳入一个详细的文档，并成为页面示意图或<strong>线框图</strong>。</p><ol><li>通过安排和选择界面元素来整合界面设计。</li><li>通过识别和定义核心导航系统来整合导航设计。</li><li>通过放置和排列信息组成部分的优先级来整合信息设计。</li></ol><h1 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h1><p>完成其他四个层面的所有目标；解决并弥补“产品框架层的逻辑排布”的感知呈现问题。</p><h2 id="感知设计"><a href="#感知设计" class="headerlink" title="感知设计"></a>感知设计</h2><p>它决定我们的设计最后要如何被人类的感觉器官感受到。感官包括：</p><ul><li><p>嗅觉和味觉：是互联网产品很少考虑的范畴，一般用在食物、香水、香味产品、新车、新硬件产品。</p></li><li><p>触觉：实物产品的触觉体验属于工业设计领域的概念。有了振动设备之后，基于屏幕的交互产品也有了触觉体验，如iPhone的3D Touch震动反馈。</p></li><li><p>听觉：声音可以应用到很多不同种类的产品中。如汽车上的不同声音能提醒你引擎是否启动、车门是否关好、安全带是否没系。游戏中背景声音，角色走路声音，跑步声音，碰撞物体声音，游戏结束声音。</p></li><li><p>视觉：几乎所有的产品都涉及视觉设计。除了主观的视觉呈现，还要检测是否把用户的注意力吸引到了正确的位置？是否用户注意的地方与他们的需求一致？有没有打乱和模糊模块之间的区别？</p><p>追踪用户眼睛移动轨迹：它们遵循的是一条流畅的路径；在不需要用太多细节吓倒用户的前提下，为用户提供有效选择的、某种可能的“引导”。</p></li></ul><p>本文内容整理自<em>《用户体验要素》- Jesse James Garrett</em></p>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 用户体验 </tag>
            
            <tag> 产品设计 </tag>
            
            <tag> 战略层 </tag>
            
            <tag> 范围层 </tag>
            
            <tag> 结构层 </tag>
            
            <tag> 框架层 </tag>
            
            <tag> 表现层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>科技，下一步 - 《必然》下篇</title>
      <link href="/2018/05/12/183630/"/>
      <url>/2018/05/12/183630/</url>
      <content type="html"><![CDATA[<p>上篇讲了科技的6个趋势（形成、认知化、信息流、屏幕化、即时获取、共享），有些已经实现了。未来，这些领域会扩展地更为庞大。</p><img src="/2018/05/12/183630/01_Background.jpg"><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>每年我们生产2万部电影，200万本新书，800万首新歌，2000亿条推特。在这数据大爆炸的时代，如何找到适合自己的信息？答案是“过滤”。</p><h2 id="过滤的方式"><a href="#过滤的方式" class="headerlink" title="过滤的方式"></a>过滤的方式</h2><ul><li>看护人过滤：对于尚未形成自己辨别能力的青少年，由权威、父母、老师帮忙过滤。</li><li>媒介过滤：由图书、电影出版方，传统视频网站，新闻首页过滤。</li><li>管理者过滤：由零售店，博物馆，书店过滤。</li><li>品牌过滤：消费者为降低选购风险和方便，倾向于挑选熟悉的品牌。</li><li>政府过滤：有违国家理念，煽动群众情绪的内容会被清除。</li><li>文化环境过滤：地域歧视，性别歧视的内容会由群众自发抗议，以舆论压力清除。</li><li>朋友过滤：身边人对我们的选择有很大影响，我们会尝试朋友喜欢的东西。</li><li>自身过滤：根据自己的喜好、三观、心态来做出选择。（现在主要的来源）</li><li>推荐引擎过滤：亚马逊、Netflix、微博、微信、头条会使用推荐引擎，利用算法来推荐我们可能会喜欢的内容。（未来重要的来源）</li></ul><h2 id="理想的过滤器"><a href="#理想的过滤器" class="headerlink" title="理想的过滤器"></a>理想的过滤器</h2><ul><li>根据你浏览记录，对你停留时间长，喜欢的内容进行标记，以推荐更多你可能喜欢的内容。</li><li>推荐你朋友喜欢的内容，使得你们有更多共同话题可聊。在Facebook你不会看到好友发的所有内容，是因为被称为“商业机密”的算法给过滤了。</li><li>推荐你现在不了解但可能会尝试的内容，比如你从来没看过音乐电影，突然某天尝试了一下，之后就喜欢的不得了。</li></ul><h2 id="过滤器商机"><a href="#过滤器商机" class="headerlink" title="过滤器商机"></a>过滤器商机</h2><p>注意力稀缺：诺贝尔奖社会学家Herbert•Simon曾说过“在信息丰富的世界里，唯一稀缺的资源就是人类的注意力”。稀缺会升高物品原有价值，一些免费的平台，推荐给你喜欢看的内容，顺便出售你的注意力给广告商。这是一个双赢的局面，比如你常上烹饪网站，谷歌可能在网站上给你展示厨具、食材、周边餐馆广告，你恰好需要。</p><p>广告去中心化：如果由个人制作广告，投放广告，向商家收取广告费，没有中间商赚差价会怎样？如果你制作或者从商家那里拿到了广告，你把这条广告发出去，其传播次数、观看次数、喜欢次数都会被内置追踪统计出来，并据此付给你报酬。</p><p>实物过滤：实体商品批量化生产，使得价格逐年下降；而体验的内容在增多，价格在逐年升高，因为人的体验无法复制。高档娱乐每年以6.5%速率增长；音乐会均价在30年内增长了400%，而同期物价才增长150%；医疗服务价格也是急速上升。或许在将来，机器人替代了人类做体力活，我们利用技术来生产“体验产品”，并把钱花在体验上。</p><h1 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h1><p>专门研究经济增长理论的纽约大学经济学家Paul Romer认为，真正可持续的经济增长来源于重组。</p><p>将多种简单技术进行重新组合，就会有无数种新产物。</p><p>短视频的拍摄、上传、分享非常方便。10s内，以正常语速可以读到40个汉字以上。多种形式视频的共存是可能的。相同的时长，可以容纳更多的短视频，数量上将呈现爆发性增长。重组的形式多种多样，电影、音频、字幕、图片、宣传片。</p><p>10s可以做什么？10秒足以学会去虾线、学会怎么把自己装进行李箱，足以将我最喜欢的《罗马假日》片段放给你看，将你带入《忠犬八公的故事》里的感人场景。</p><p>既然制图软件、代码编辑器、Git管理可以支持撤销、回退，那么体验为什么不可以呢？突然想念起在悉尼邦迪海滩的某一刻，却又不能瞬间传送，依靠VR（沙滩画面、海鸥鸣叫、或许再吹一股咸咸的人造海风）可以让你瞬间身临其境。</p><p>前两年炒的热闹的互联网+，现在的AI+，都是对传统行业重组的强烈意愿。</p><h1 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h1><p>从平面的2D电影，到可以使想象力跟着画面漫游的3D，体验有了质的飞跃。</p><p>如果再加上电动椅子的摇晃，喷气装置，或许加点用微电流刺激产生的电影中的真实触感，VR可以把你带入喜欢电影场景。</p><p>微软的HoloLens可以让一群人在虚拟的空间里构建模型，在其中互相交流。电影《少数派报告》中，所有人与同一块显示屏交互，而看到的都是自己个性化的内容。</p><p>交互方向：</p><ol><li>不断给自己制造的实体物品添加新的传感器和感官功能。</li><li>可互动的屏幕，无处不在，随手可触。</li><li>最大程度的互动能够容纳我们完整个体，置身其中。</li></ol><p>电影《头号玩家》里的场景，看起来也不是不可能实现。将来某天，人类无需再制造实体物品而人人衣食无忧，所有人都在销售和购买”体验产品”，女孩子可以骑着自己喜欢的独角兽🦄飞来飞去。人不再需要身份证，瞬间完成扫描指纹、虹膜等多种特征即可确认身份，你就是密码。</p><h1 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h1><p>科技虽然发展迅速，但这些技术没有使我们变得完全了解自己，你的医生也不能，仍然有很多疾病、癌症无法治疗。现在正在研究的电子药物，集温度计、心率检测仪、运动追踪器、脑电波探测仪等于一体，使我们完全了解自己变得可能。</p><h2 id="自我追踪"><a href="#自我追踪" class="headerlink" title="自我追踪"></a>自我追踪</h2><p>在当下，那样的场景只有在电影中存在。人们想要完全了解自己却是真实的，有人在追踪测量自己的饮食、睡眠、心情，有人在追踪运动轨迹、力量，有人追踪自己时间用在了哪里，这一年和见了哪些人，亲密度增加了多少等数据。</p><p>追踪不局限于数字化的范畴。在陌生的城市里，你能分得清东南西北吗？找路标，看太阳？Out了，而且这方案并不迅速。如果我们想向北走，脑电波传输，身体能感知北边的方向。现在已经有人制造了一根皮带，打开开关，腰部就能感受到北方的“召唤” - 震动，仿佛赋予了身体辨别北方的特殊能力。</p><h2 id="非主动追踪"><a href="#非主动追踪" class="headerlink" title="非主动追踪"></a>非主动追踪</h2><p>现在想要追踪运动轨迹和步数，需要带上手机或者手表；想要记录时间都去哪儿了，需要自己手动开始/暂停一个流程定时器。</p><p>MIT有人每天一醒来戴着摄像机记录生活，一戴就是近30年。Google Glass是目前最优雅随时记录生活的表现方式，未来当然不止于此，一起改变的，或许还有人们的认知，不再介意被拍摄，对摄像头熟视无睹。记录生活，你可以回顾任意一天，任意瞬间。</p><h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><p>从2006年起，美国的每辆汽车的仪表盘下都有OMB芯片，用以追踪行驶里程、车速、急刹次数、过弯速度以及油耗。Tesla的车辆数据可以上传至服务器，以及即将到来的无人驾驶汽车，这些公司都在研究追踪和远程控制车辆的解决方案。</p><p>随着技术的提升，追踪芯片的成本下降，越来越多的物品都能连上网络，随时获取状态，可以解决现在遇到的许多问题。</p><h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>最初，提问只有从长辈，邻居，村民口中知道答案，答案很可能是不同的；后来有了电话，可以拨打114查询；有了互联网，可以随时谷歌、百度数学问题，记不起下半句的诗句，地球到月亮的距离，点击链接查看；随后有了Siri和谷歌的即时答案结果，可以回答许多基础的，具有标准的问题。</p><p>随着可以搜到的答案越来越多，人的好奇心也越来越多，想要追本溯源。会提问变得重要起来。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>这部分就没什么可总结的，KK描述了一个极度遥远的未来。</p><p>但我们能做的就是当下，从现在开始共享，一步步迈向一个乌托邦的未来。如果觉得你的虚拟物品（文章、图片、视频）分享出去比躺尸在你的硬盘里更有意义，那就大胆分享出去吧。</p>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技 </tag>
            
            <tag> 趋势 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 过滤 </tag>
            
            <tag> 重组 </tag>
            
            <tag> 交互 </tag>
            
            <tag> 追踪 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>科技，下一步 - 《必然》上篇</title>
      <link href="/2018/05/06/230704/"/>
      <url>/2018/05/06/230704/</url>
      <content type="html"><![CDATA[<p>为什么会用“必然”这么一个强烈的词？</p><p>我们通常说的“必然”是指一定会发生的事，比如不吃饭必然会饿；在逆流的河水中，不前进必然后退。</p><p>KK笔下的“必然”，给了我们一种新的解释，即趋势。趋势是指从更大的角度，而不局限于具体的表现形式，如新能源汽车是必然，特斯拉不是必然。拥抱变化、顺势而为，都要求我们留意趋势，在正确的时间做恰当的事情。正所谓“好风凭借力，送我上青云”嘛，喂(#`O′)，没有说你是风口的某种动物啦。</p><img src="/2018/05/06/230704/01_Background.jpg"><h1 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h1><p>科技“进化”的形成。</p><p>软件产品的推出，版本的更新周期越来越短，甚至在敏捷开发下，一周提测几个版本也不稀奇。如此频繁的更新，是否真的还需要用户知道更新的细节，或许未来的更新都是无感更新，用户不需要知道你修复了几个bug，不需要知道你优化了哪里，软件都变得如水如电，稀松平常。正如人渴的时候，不需要知道是搬运工的水，或者天山，或者南山的水。</p><p>新平台的形成。</p><p>苹果从施乐实验室“借鉴”了用户界面，使得非专家用户也能使用电脑；微软从苹果“借鉴”了用户界面，使得普通人也用得起电脑。有无数的产品、公司是依托在这些系统之上生存。既然过去知道良禽择木而栖，那么现在，又有什么理由选择背离大平台呢？过去的平台是操作系统，现在的平台是微信、Facebook、亚马逊，通过提供的API就可以连接上亿的用户。</p><p>KK说，如果现在的你觉得上个世纪的互联网机会很多，那么几十年后，你也会听到后辈说此刻的机会很多。当下，就是创业的最佳时机，如果你准备好了，就创立或加入一家新公司，与一群志同道合的人，共同进步。</p><h1 id="认知化"><a href="#认知化" class="headerlink" title="认知化"></a>认知化</h1><p>赋予对象认知能力，即AI+。</p><p>阿里的人工智能 - 鹿班，每秒钟出8000张海报，去年双十一出了4亿张海报；特斯拉工厂大量使用机器人，保证稳定性和生产速度。或许头一天下棋还输给小学生的AI，第二天就能拿个什么冠军，毕竟AI不吃饭，用思维下棋与用手下棋的速度没可比性。</p><p>利用人工智能创作个性的电子音乐、游戏背景音乐；利用人工智能改造洗衣机，或许你将拥有一台到处走，寻找你乱丢的脏衣服的洗衣机；利用人工智能进行精准营销；利用人工智能匹配雇佣关系、租赁关系、甚至恋爱关系；无人驾驶汽车。谷歌利用搜索引擎、Youtube资源训练人工智能，而不是反过来。</p><h1 id="信息流"><a href="#信息流" class="headerlink" title="信息流"></a>信息流</h1><p>在过去，你有一个面包，能支配固定等量的劳动力。</p><p>今天，你有一款免费软件产品，能支配多少劳动力是不可知的，因为它取决于用户的多少。用户支付的总时间货币和总虚拟货币，决定你产品的价值。</p><p>过去的实体物品，都可以变成流动的，即按需服务。不用买车，有了Uber，你也可以坐到大众、奔驰、特斯拉；操作系统、软件的更新，也可以让你使用新功能；不再需要购买专辑，订阅Apple Music，你可以听到几辈子也听不完的音乐；有了电子书，想看的时候，买完就能立刻阅读；对方转账，不再需要在到账前的几天里担忧，都是实时知晓（吐槽下澳洲，2017的时候，跨行转账还要几天到账，至今没学会如何查询对方是否已转账了）。</p><p>在免费产品上，添加附加值以出售：</p><ol><li>即时性。电影上映一段时间后，网上就有免费片源，可人们还是了第一时间去电影院花钱看。</li><li>个性化。免费的QQ空间，付费的个性化装饰；免费的游戏，个性化的皮肤。</li><li>解释性。免费的软件，付费的服务支持。</li><li>可靠性。免费的盗版软件，付费的正版软件升级。</li><li>可访问。免费的音乐软件，付费的Apple Music（歌曲最多）。</li><li>实体化。免费的3D模型，付费的3D实物；免费的音乐，付费的现场演唱会。</li><li>可赞助。免费软件，“付费”的广告。</li><li>可发现。没人看到的产品没有价值，无论价格高低。</li></ol><h1 id="屏幕化"><a href="#屏幕化" class="headerlink" title="屏幕化"></a>屏幕化</h1><p>任何信息都可以放入屏幕阅读，电子书、文档、图片、视频。</p><ol><li>即时性。在屏幕上可以随时随地、碎片化地阅读信息。</li><li>链接性。屏幕上的富文本支持，可以在页面上点击链接，查看定义、链接到更多的信息。</li><li>便携性。一部手机可以放一辈子都读不完的内容。</li></ol><p>屏幕化使得阅读社交化更容易。</p><p>如现在使用的微信读书，每周阅读十小时，在上面划线、写想法、回顾总结，给感到共鸣的想法点赞、回复，去书友书架找喜欢的书籍，加好友聊共同爱好，和好友比赛谁读的内容多。</p><p>屏幕化改造了书籍，接着改造视频和电影，改造游戏和教育，最后是无所不在的屏幕化。</p><h1 id="即时获取"><a href="#即时获取" class="headerlink" title="即时获取"></a>即时获取</h1><p>Uber是最大的租车公司，却不拥有车；微信是最大的社交平台，却不生产用户；Airbnb是最大的住宿提供商，却不拥有房屋。</p><p>用Uber随时可以坐私家车，用Netflix随时可以看视频，用Apple Music随时可以听歌，但我们却从未真正占有一辆车、一部视频、一首歌。你已经坐在自助餐厅里了，伸手即是美食，还担心没得吃吗？</p><h2 id="去物质化"><a href="#去物质化" class="headerlink" title="去物质化"></a>去物质化</h2><p>现在的啤酒罐重量是60年前的1/5重，也摆脱了开瓶器；电视、电脑在变轻；汽车使用性能更好且更轻的材料；使用电子书代替纸质书（减少树木、运输、库存场地等物质资源）。</p><ul><li>服务化。从过去的购买并拥有，到现在的订阅模式，促使生产者与消费者之间保持永久联系。时间越长，服务越了解你，你更依赖它，就像你们结婚了（想想你的电话号码、音乐、视频、杂志会员）。</li><li>按需使用。准备出行，一辆车就过来只为你服务；准备去纽约，一间客房就只属于你；房间脏了，一位阿姨就过来给你打扫两小时。大家都想做“X领域的Uber”，其核心业务是将分散在各处的提供方与需求方匹配。</li><li>去中心化。比特币的诞生，区块链的火热，都是人们对去中心化的渴望。</li></ul><h2 id="平台协同"><a href="#平台协同" class="headerlink" title="平台协同"></a>平台协同</h2><p>平台就像是一个百货公司，出售并非由它创造的商品。</p><ul><li>第一代平台：像微软的Windows操作系统，任何人都可以随意编写并出售软件。</li><li>第二代平台：像苹果的App Store，吸收了更多市场属性，苹果公司负责过滤应用和调控市场。iPhone每添加一个新的硬件，多种创新的应用就会出现。</li><li>第三代平台：像微信、Facebook这样，并非传统的双边市场撮合买卖双方，而是多边市场。用户生产信息，平台使用信息来给用户匹配，用户的注意力销售给广告商，交易方并不直接接触。</li></ul><h2 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h2><p>网页是众多超链接的文件，云端则是超链接的数据。</p><p>我们的聊天记录、音乐、视频、书籍、微博、资讯都来自云端。不会因为我们手机、或者一台服务器的故障而丢失数据。云端功能越强大，我们就能随时处理更多的问题。亚马逊云、阿里云、腾讯云提供了云服务，新科技公司不再需要从0到1地购买实体主机、编写代码来搭建基础设施，而可以直接选择订阅需要的云功能，即“基础设施即服务（IaaS）”</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><p>与传统的版权主义不同，利于共享的”知识共享”版权许可协议被广泛接受，鼓励人们使用、修改自己的图片、文本或音乐，即默认共享。</p><p>人们在网上有着强烈的共享意愿。在Facebook、Instagram、朋友圈每天都有数十亿的个人照片被上传。在网络上共享的还有个人状态、地理标注、餐馆评价、生活视频。</p><p>“知识共享”许可，也就意味着你的是我的，我的是你的。与实体物品不同，网络文件的共享，同思想的传播一样，共享的次数再多也不会稀释任何一份。</p><p>人们不仅愿意共享文件，还愿意共同协作。在Github上，每天都有无数的软件源码共享出来，任何人可以基于这个版本进行改进，Facebook、Google、Airbnb、阿里巴巴等大公司也在上面开源了许多的项目代码，使得小公司可以快速地迭代、聚焦于根本。</p><p>共享不止于网络行为，也延伸到生活中。今天的人们，可以随时叫一辆Uber，也可以随时开走一辆共享汽车，住进一户人家。还有众筹和众包，前者允许生产者有了生产意愿和目标，就可以发布出去，让有共鸣的人们参与其中出资预定，使得产品得以生产；后者允许每个人都可以成为需求的提供者，任何人都可以去送外卖，任何人都可以顺路替他人有偿捎带物品。</p>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科技 </tag>
            
            <tag> 趋势 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 屏幕化 </tag>
            
            <tag> 即时性 </tag>
            
            <tag> 共享 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>引爆用户自传播 -《让创意更有黏性》</title>
      <link href="/2018/05/01/232220/"/>
      <url>/2018/05/01/232220/</url>
      <content type="html"><![CDATA[<p>谣言为什么总是传播广泛？</p><p>日本核电站泄露，我国沿海城市出现的抢盐潮；微信朋友圈里被人转发的谣言文章；某人在酒吧喝完陌生人给的一杯酒，醒来后发现自己躺在满是冰块的浴缸里，肾已被摘去。</p><p>为什么有些文章、故事、谚语很容易被记住？</p><p>这么多年过去了，还记得鲁迅在课桌上刻的“早”字，虽不知是否真有此事；大家都听过“无风不起浪”吧，这句谚语在全球至少55种语言里，可以找到对应的描述。</p><p>这些经典案例，一定有什么共同之处，使得它们被广播广泛。如果可以提取出一套通用的模板，套用在产品、文案上，就具有了可以引爆用户自传播的天然属性，一触即发。</p><img src="/2018/05/01/232220/ideas.jpg"><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><p>一次宣传10个新功能，等于1个也没宣传。</p><p><strong>提取核心：聚焦、单点突破。</strong></p><p>在制定新产品需求，或者迭代新功能的时候，看着文档里的每项功能点，好像都很重要，但是设计、开发资源又不够，该怎么办呢？</p><p>提取核心最关键，可以把你从犹豫不决中拯救出来，集中火力，单点突破。比如要做一款社交软件，交流功能肯定是放在第一位，而不是想着先加点直播、加点应用内可以玩的小游戏。</p><p><strong>传播核心：善于利用人们已有的知识。</strong></p><p>当你决定了要做的核心功能，接下来就是考虑如何传播。</p><p>借助基模：有种进口水果的叫浮露，它长得像草莓，红红的，吃起来像柠檬，酸酸的。</p><p>现在你脑海里是不是浮现了它的样子，同时口水分泌加速？这就是基模的力量（别搜了，这水果是我编的 :D）。跟别人描述你的产品概念时，不要说“我要做一款基于熟人关系的实时社交软件，让人们可以随时随地交流想法、心情。”，直接说你要做一款微信1.0就好了。</p><p>可以从以下6个方面，检验你的创意是否具有很强的传播特性。</p><h1 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h1><p><strong>惊奇：要吸引他人注意，就得打破常规。</strong></p><p>一架从纽约飞往北京的飞机，起飞工作准备就绪，广播开始讲解安全注意事项，你像往常一样埋着头玩手机，突然听到“本次航班即将起飞，将在15小时候后抵达莫斯科，俄罗斯”，这时大家都疑惑地抬起头看向空姐，广播继续说道“那是不可能的。”。先不论这种方式，但的确引起了你的注意，不是吗？</p><p><strong>兴趣：维持他人注意。</strong></p><p>你正在楼下餐馆吃饭，这时新闻App推送了条周边新闻“xx区多家餐馆卫生不合格，”，这时你是不是要放下筷子，赶紧点进去看下什么情况？（现在很多新闻App，就喜欢做标题党，依赖算法，加倍利用人性的弱点。）</p><h1 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h1><p>你知道《狐狸与葡萄》吗？如果没有印象了，那你肯定知道“吃不到葡萄说葡萄酸”这句话吧。</p><p>你知道“原发性心肌病”的意思吗？心肌病 - 你的心脏有问题；原发性 - 我们也不知道是什么问题。。。</p><p>你知道Caterpillar的意思吗？如果我把这个单词放在一张毛毛虫图片上呢？这就是流行的看图学单词</p><p>抽象的观点不容易被人理解和记忆，具体让我们利用现有知识和感官来理解抽象概念。</p><h1 id="可信"><a href="#可信" class="headerlink" title="可信"></a>可信</h1><p><strong>外在可信，是最常见的增加可信度的方式。</strong></p><p>权威和反权威。从美国中情局逃出去斯诺登，在揭露美国“棱镜”计划后，如果他推出安全产品，一定会吸引一大批用户使用；手机厂商把大量的预算花在请明星上；如果李开复明天推荐一本书，销量一定会大增，其实每个人都在追星，我们会信任这些人推荐的东西。反权威就是某事的受益者，现身说法，比如中本聪跑出来，教你区块链致富之道。</p><p><strong>内在可信，以下几点可以增加内在可信。</strong></p><p>生动细节：越多细节，越逼真。善于撒谎的人，能给你编出具体到某个时间点做了啥。</p><p>统计数据：数据统计的意义，代表了某个分类的占比，十分清晰。</p><p>“西纳特拉测试”：西纳特拉在其著名的歌曲《纽约，纽约》里唱到：“If you can make it here, you can make it anywhere”，就是说你连奥巴马都拉来给你当投资人了，其他投资者则纷至沓来。</p><p>可检验性认证：“买葡萄啦，十块一斤，不甜不要钱”，这就是可以马上检验的。</p><h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p><strong>让人关心在乎：针对不同用户，使用不同策略。</strong></p><p>对于三四线城市的电商平台用户来说，看得见的价格实惠比宣传品质生活更有吸引力。而对于白领、新青年，品质更为重要，愿意花更多的钱“享受”生活。</p><p><strong>马斯洛需求层次：人的所有需求皆在其中。</strong></p><p>生理、安全、社交、尊重、自我实现。需求有层次，但不能按需求层次来划分人群，每个人有着对底层安全需求到上层自我实现的需求。要确定好自己的产品定位。</p><h1 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h1><p><strong>代入情景：故事的力量，第一层能够使人产生联想。</strong></p><p>如小说、恐怖电影、奢侈品广告。用户代入角色后，便从被动的接受者变为积极的参与者。</p><p><strong>自我启发：第二层能够引人思考。</strong></p><p>传达公司经营理念、服务理念。你不必是每天脑子里可以蹦出一万个想法的人，但你可以是从别人的想法里淘出金点子的人。</p><p>挑战情节：以弱胜强、以小博大，鼓舞人心；联系情节：从故事情节联系到生活，指引人们做出选择，如心灵鸡汤、梁祝等爱情故事；创造情节：以打破常识和创意革新的办法处理问题。</p><p>制定产品、制作游戏、传达理念、用户体验营销、增长黑客、自然增长，都可以用上面的6个点作为指导。</p>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 创意 </tag>
            
            <tag> 自传播 </tag>
            
            <tag> 自然增长 </tag>
            
            <tag> 用户体验 </tag>
            
            <tag> 社交 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>整体性学习 - 《如何高效学习》</title>
      <link href="/2018/04/25/085341/"/>
      <url>/2018/04/25/085341/</url>
      <content type="html"><![CDATA[<p>为什么学了那么多年英语，还停留在“Hello”、“How are you?”阶段？</p><p>为什么在大学里，别人临时抱佛脚，还比你考的分高很多？</p><p>为什么读了那么多书，你却只记得个书名？</p><p>在很多人的眼里、数学是数学、生物是生物，两者是完全不同的学科，没有交集。如果说它们不只是孤城，而是可以相互连接成一个帝国，你会不会惊讶？</p><p>今天要介绍的<strong>整体性学习</strong>，就是为了刷新你的认知，高效地吸收学习，把你知道的商业、产品、设计、心理学、社会学、编程等孤立的知识，建成一个庞大的帝国，达到高效记忆和应用知识的目的。</p><p><strong>注意：</strong>这不是一蹴而就方法，需要你主动练习一段时间，形成习惯后；等潜意识自然而然地接手这套路，你就会变得轻松学习、灵活应用。</p><p>下方是我梳理的框架图，先有个大致了解，再阅读细节。</p><p><em>《如何高效学习》 - 斯科特•扬</em></p><img src="/2018/04/25/085341/01_Learn.png"><h1 id="主要观点"><a href="#主要观点" class="headerlink" title="主要观点"></a>主要观点</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>信息就像大楼、大脑对知识的掌握程度，取决于你设计的结构（城市）能够盖多少信息（大楼）。</p><p>有的人数学很差，英语却很好；有的人英语很差，物理、化学却非常厉害。</p><p>你对喜欢的科目投入很多的时间，不断吸收信息，时常调整结构来容纳更多的信息；而其他科目，即使投入很多时间，也只是随便找了块地修些楼。没有好的结构，就像没有设计好的城市，到处是大楼，道路狭窄、经常塞车。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>建立模型，是为了压缩信息，即关键点。结构是由许多模型组成的。比如一座城市，有居民楼模型、商场模型、公园模型、车站模型。</p><h2 id="高速公路"><a href="#高速公路" class="headerlink" title="高速公路"></a>高速公路</h2><p>只有城市，还不能发挥大脑的作用（“你们对力量一无所知~”）。高速公路就是不同城市之间的联系，也就是不同结构之间的联系、不同学科之间的联系、不同领域之间的联系。由不同结构连接起来的整体，也是结构。</p><h1 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>获取就是指信息通过眼睛、耳朵进入大脑的过程。获取阶段的目标是信息要准确，然后压缩信息量。</p><p>3个主要目标：</p><ul><li>简化。比如“我是，我是，我是，我是，我是，我是”，可简化为<strong>“我是 x 6”</strong>。对于书籍、视频，直接跳过不重要的内容（比如引言，废话，感谢）。</li><li>容量。明白简化信息后，就该去获取更多的信息啦。（一年读几十本肯定比比读2、3本要知道的多。）</li><li>速度。时间是有限的，效率很重要。（这需要好的阅读和听讲方法，稍后会介绍。）</li></ul><p><strong>反问测试法：</strong>我以前看过/听过这个知识吗？</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>理解就是了解信息的基本意思，并放在上下文中进行联系。</p><p>只获取而不理解，是填鸭式的学习。（比如学习冒泡排序的时候，是一步一步引导你去理解、掌握的，而不是让你把代码段背下来。）</p><p><strong>反问测试法：</strong>我理解了这个知识的含义（字面/深层）吗？</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>（重点）这一步就是打造模型、建立高速公路、构建良好的结构。</p><p>3种主要方式：</p><ul><li>深度拓展 - 溯源。缺点是要花更多的时间。</li><li>横向拓展 - 联系。建立模型，在模型与相同领域里已学的知识之间建立联系。（比如学世界历史的时候，联想到已学的中国历史，你就知道别人在忙着工业革命的时候，乾隆也忙着带领中国由盛转衰呢。）</li><li>（重点）纵向拓展 - 学习迁移。知识都遵循一定模式，同样的模式，也可能应用到其他领域中。（比如学会了数学有利于学习物理；学会了英语有利于学习西班牙语。）</li></ul><p><strong>反问测试法：</strong>我知道这个知识产生的背景，以及和已有的知识有联系吗？</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>学以致用，将知识应用到生活中，解决问题。</p><p><strong>反问测试法：</strong>我把这知识用起来了吗？</p><h2 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h2><p>实际应用后，对知识做微调。（如添加特殊情况、删除知识间与现实不符的联系。）</p><p><strong>反问测试法：</strong>修正了过去形成的错误模型吗？删除了错误的结论吗？</p><p><strong>小结：不一定要按这个顺序，这里是为了有规律可循，便于掌握。后期可以自由决定按照什么步骤进行学习。</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="信息类型"><a href="#信息类型" class="headerlink" title="信息类型"></a>信息类型</h2><p>对于不同的领域、学科、知识，虽然学习的过程类似，但是知识的结构是不同的。</p><p>随意信息：是一系列事实、日期、定义、规则、公式；缺少逻辑分类；需要死记硬背。（比如各种历史事件、二十四节气。）</p><p>观点信息：是存在争论的信息。（比如最好的语言是Java还是Swift？）</p><p>过程信息：是教导你怎么行动的信息。（比如学游泳、学写第一个”Hello World!、学做番茄牛腩。）</p><p>具体信息：是在实际中可以看到、听到、触摸到的信息。（比如大象比狗大、冰雪会融化）</p><p>抽象信息：是与人的感官没有直接联系的信息。（比如数学、微积分、心理学、编程）</p><h2 id="获取知识"><a href="#获取知识" class="headerlink" title="获取知识"></a>获取知识</h2><h3 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h3><p>解决容易分心问题、一段文字要读好几遍的问题、读的太慢的问题、笔记记太多/记太少，也还是不懂的问题</p><ul><li><p>指读法：用手指指着要阅读的地方，可以提高阅读速度，不容易分心。</p></li><li><p>练习阅读法：不同于一般阅读。目的不是吸收阅读的内容，是为了训练自己以尽可能快的速度理解所读的内容。</p><p>阅读速度练习：</p><p>1.拿本没读的书，标记准备读的地方，设定3分钟，用指读法，以稍快于自己能读懂内容的速度进行阅读。</p><p>2.计算<code>读的行数 x 每行平均字数 / 3</code>。能测出你提高阅读速度后，能达到的程度。</p><p>​</p><p>理解力练习：</p><p>1.读3分钟材料，凭记忆写下你记住的知识点。</p><p>2.再读一遍材料，边读边记下知识点。</p><p>3.比较两份记录，统计下凭记忆写下的，正确的、错误和漏写的有多少？</p><p>4.计算<code>正确的 - （错误的、漏写的）/ 所有的知识点数</code>。能测出你以一定阅读速度阅读这类型材料的理解能力。</p><p>​</p><p>通过降低阅读速度，可以提高理解能力，达到最快的阅读速度 + 最好的理解能力。</p></li><li><p>积极阅读法（用于专业性的书籍）：强调深入理解材料。1.这一节主要观点？；2.怎样才能记住它？；3.怎样才能拓展它、应用它？</p></li></ul><p>快速阅读是一项技能，需要反复练习。</p><p><strong>挑战：</strong></p><ol><li>买一两本内容适合做快速阅读练习的书。</li><li>3周内，每天15分钟进行阅读速度和理解力的练习（见前面“练习阅读法”）。</li><li>练习2周指读法。</li><li>每周练习1次积极阅读法。</li></ol><h3 id="笔记流"><a href="#笔记流" class="headerlink" title="笔记流"></a>笔记流</h3><p>遵循“一次学会”的原则，不要想着记完笔记，以后再学，更多的时候你不会再想起去看笔记。</p><ol><li>只记主要观点，用词语、短句概括。</li><li>在观点间画箭头，划线、画圈建立联系。</li></ol><p>（这有个学生挑战，有需要的可以去书上可以找。）</p><h2 id="理解和拓展"><a href="#理解和拓展" class="headerlink" title="理解和拓展"></a>理解和拓展</h2><h3 id="比喻法"><a href="#比喻法" class="headerlink" title="比喻法"></a>比喻法</h3><p>比喻是一种文学的用法，用来将某个物体与其他物体联系起来。（比如跟你说大众有款甲壳虫车，即使你没见过，也猜到什么样子了。）</p><p>（这有个学生挑战，有需要的可以去书上可以找。）</p><h3 id="内在化"><a href="#内在化" class="headerlink" title="内在化"></a>内在化</h3><p>指不仅仅在脑海中出现画面，还有声音、触觉、情感等。</p><ol><li>明确要内在化的概念。（是编程函数，还是数学概念？）</li><li>在脑海中绘制图像。（不习惯的话，可以在纸上画草图。）</li><li>静态图还是动态图？</li><li>加上其他感官。（用手摸它、嗅它、听它，赋予情感。）</li></ol><p><strong>挑战：</strong></p><ol><li>准备纸、笔。</li><li>从书中找2个概念或观点。</li><li>在脑海中绘制图像，加入感官知觉、情感。</li><li>根据脑海中的图像，在1分钟内画出来。</li><li>坚持两周，每天练几个。</li></ol><h3 id="图表法"><a href="#图表法" class="headerlink" title="图表法"></a>图表法</h3><p>是内在化的简化。</p><p>三种主要图表类型：</p><ul><li>流程图：绘制一系列的步骤；绘制历史事件；绘制一个系统（函数的执行过程）。</li><li>概念图：写出观点，在观点间画箭头并在箭头上加描述；从主角开始，描绘红楼梦里的角色关系；</li><li>图像：涂鸦代替前两个图中的文字和联系，更生动，容易记。</li></ul><p><strong>挑战：</strong></p><ol><li>找一个观点/概念。</li><li>设定2-5分钟，上面图表形式三选一，开始画。</li><li>时间到了后，统计工作量。（包括有多少信息、建立了多少联系）</li><li>每天1次，重复2周。</li></ol><h3 id="处理随意信息"><a href="#处理随意信息" class="headerlink" title="处理随意信息"></a>处理随意信息</h3><p>联想法：将一系列观点串在一起，按顺序排列，形成链条。记住任意一环，都能寻找到其他环节。（比如班上同学排成一列，不要记住每个人的顺序，只需要每个人记住自己前后是谁。）</p><p>挂钩法：类似于联想法，没有顺序，你能回忆起单个信息。（比如看图记单词/小学字母表，“e”的旁边还画了一只鹅。就算忘了字母顺序了，看到鹅还能记起“e”这个字母来。）</p><p>信息压缩法：目标是减少信息的容量。归类，建立逻辑联系。（比如急救术中的术语RED，R、E、D又分别代表3个单词。记得时候记住RED，用的时候再还原。类似于旅行前把衣服真空压缩，要穿的时候再还原。）</p><h2 id="纠错和应用"><a href="#纠错和应用" class="headerlink" title="纠错和应用"></a>纠错和应用</h2><p>实际应用：将知识应用于实际，会记得更牢。（比如用统计学解决生活中的问题；用编程中学的算法，在黄页书中快速找到某人；读历史，以史为镜。）</p><p>模型纠错：在实践中发现问题，快速修正。就像代码需要运行后，才发现错误。</p><p>以项目为基础的学习：设定1-3个月的目标，过程即学习！记录进度！</p><h1 id="如何超越"><a href="#如何超越" class="headerlink" title="如何超越"></a>如何超越</h1><h2 id="高效率"><a href="#高效率" class="headerlink" title="高效率"></a>高效率</h2><ol><li>能量管理：不要把日程安排满满的；设定90分钟，集中注意力完成任务；每周运动几次；至少7、8个小时睡眠；健康的饮食，少吃多餐；多喝水；一周至少休息一天；晚上做点轻松的。</li><li>聪明学习：获取 - 理解 - 拓展 - 应用 - 纠错。学十几个小时，未必能考高分/学到很多东西。</li><li>不拖延：把某个任务定在一个时间点，一次性完成；每天检查当日任务清单。</li><li>批处理：将类似的工作放在一起处理。（如一次性接收邮件/微信，不要随时盯着邮件/微信，减少分心频率。）</li><li>有组织：物品放在固定位置；使用记事本/App，随时记录；使用日历和清单，设定任务和截止日期。</li></ol><h2 id="自我教育"><a href="#自我教育" class="headerlink" title="自我教育"></a>自我教育</h2><ol><li>好习惯：每日阅读，一年50本以上；每日练习；每日目标。先坚持30天习惯！继续坚持！享受习惯！</li><li>克服障碍：写下障碍，使用网络，书籍，视频解决障碍。</li><li>设定目标：每年阅读书籍数量；为项目工作，过程即学习；在某截止日期前，学会某件事。（设定目标的技巧：写下目标！有判断标准的目标！设定努把力可以达到的截止日期！目标具体化到每周、每天！经常查看目标进度！）</li></ol>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> study </tag>
            
            <tag> information </tag>
            
            <tag> productivity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS动画之UIView动画</title>
      <link href="/2018/04/24/091143/"/>
      <url>/2018/04/24/091143/</url>
      <content type="html"><![CDATA[<p><strong>前言</strong></p><p>对于一个App，能完成基本功能，只能算及格。优秀的交互、视觉能够提升用户体验，够得上优秀。再加上细节、打动人心的动画，就更完美了。</p><p><a href="https://github.com/ronansparks/UIView-Animation.git" target="_blank" rel="noopener">Github下载Demo</a></p><p><em>环境： Swift 4.1  Xcode 9.3</em></p><h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><p>通过改变视图（UIView）的属性值来创建动画。</p><h2 id="可设置的属性"><a href="#可设置的属性" class="headerlink" title="可设置的属性"></a>可设置的属性</h2><p>坐标尺寸类：</p><ol><li>大小（bounds）：视图会移到新位置，修改尺寸</li><li>中心坐标（center）：视图会移到新位置，修改中心点</li><li>大小及原点坐标（frame）：视图移到新位置，修改尺寸和中心点</li></ol><p>视图显示类：</p><ol><li>透明度（alpha）：可以产生淡入淡出效果</li><li>背景色（backgroundColor）：可以产生颜色渐变效果</li><li>隐藏（hidden）：可以制作翻页隐藏/显示效果</li></ol><p>形态变化类：</p><ol><li>变换（transform）：可以实现旋转、形变、移动、翻转效果</li></ol><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>iOS 4 之后，苹果推荐使用Block动画方法。（iOS 4 之前有种手动开始、结束动画的方法。也就没必要介绍了。）</p><ol><li>普通动画，没有回调</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval) {    //动画        }</code></pre><ol start="2"><li>普通动画</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, animations: {    //动画}) { finishFlag in    //动画完成回调        }</code></pre><ol start="3"><li>延时动画。还可设置过渡效果</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, delay: TimeInterval, options: UIViewAnimationOptions, animations: {    //动画        }) { finishFlag in    //动画完成回调        }</code></pre><ol start="4"><li>弹性动画。还可设置过渡效果、振动效果（0-1）、初始速度</li></ol><pre><code class="swift">UIView.animate(withDuration: TimeInterval, delay: TimeInterval, usingSpringWithDamping: CGFloat, initialSpringVelocity: CGFloat, options: UIViewAnimationOptions, animations: {    //动画}) { finishFlag in    //动画完成回调}</code></pre><ol start="5"><li>帧动画。设置动画时长、延迟时间、过渡效果</li></ol><pre><code class="swift">UIView.animateKeyframes(withDuration: TimeInterval, delay: TimeInterval, options: UIViewKeyframeAnimationOptions, animations: {    //添加关键帧。从0开始，时长为 总时长 x 0.2    UIView.addKeyframe(withRelativeStartTime: 0, relativeDuration: 0.2, animations: {    })    //添加关键帧。从总时长 x 0.2开始，时长为 总时长 x 0.3    UIView.addKeyframe(withRelativeStartTime: 0.2, relativeDuration: 0.3, animations: {    })    //添加关键帧。从总时长 x 0.2开始，时长为 总时长 x 0.5    UIView.addKeyframe(withRelativeStartTime: 0.5, relativeDuration: 0.5, animations: {    })}) { finishFlag in    //动画完成回调        }</code></pre><h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>这里只列举写常用的效果，更多参数见开发文档。</p><p>循环参数：</p><ul><li>repeat：无限循环</li><li>autoreverse：动画完成后，再往反方向进行一次</li></ul><p>速度参数：</p><ul><li>curveLinear：匀速</li><li>curveEaseIn：加速</li><li>curveEaseOut：减速</li><li>curveEaseInOut：先加速、后减速</li></ul><p>转场参数：</p><ul><li>transitionFlipFromLeft：从左翻转</li><li>transitionFlipFromRight：从右翻转</li><li>transitionFlipFromTop：从上翻转</li><li>transitionFlipFromBottom：从下翻转</li><li>transitionCurlUp：从上卷曲翻页</li><li>transitionCurlDown：从下卷曲翻页</li><li>transitionCrossDissolve：旧视图溶解过渡</li></ul><h3 id="帧动画效果"><a href="#帧动画效果" class="headerlink" title="帧动画效果"></a>帧动画效果</h3><p>这里只列举写常用的效果，更多参数见开发文档。</p><p>循环参数：</p><ul><li>repeat：无限循环</li><li>autoreverse：动画完成后，再往反方向进行一次</li></ul><p>运算模式参数：</p><ul><li>calculationModeLinear：连续</li><li>calculationModeDiscrete：离散</li><li>calculationModePaced：均匀</li><li>calculationModeCubic：平滑</li><li>calculationModeCubicPaced：平滑均匀</li></ul><img src="/2018/04/24/091143/01_Keyframe.png"><h1 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h1><h2 id="单个视图"><a href="#单个视图" class="headerlink" title="单个视图"></a>单个视图</h2><pre><code class="swift">UIView.transition(with: UIView, duration: TimeInterval, options: UIViewAnimationOptions, animations: {    //动画}) { isFinished in    //动画完成回调   }</code></pre><h2 id="从旧视图转到新视图"><a href="#从旧视图转到新视图" class="headerlink" title="从旧视图转到新视图"></a>从旧视图转到新视图</h2><pre><code class="swift">//第一个view是旧视图、第二个view是新视图UIView.transition(from: UIView, to: UIView, duration: TimeInterval, options: UIViewAnimationOptions) { isFinished in    //动画回调}</code></pre>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> uiview </tag>
            
            <tag> 动画 </tag>
            
            <tag> keyframe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品需求 - 从理解到实施</title>
      <link href="/2018/04/19/175651/"/>
      <url>/2018/04/19/175651/</url>
      <content type="html"><![CDATA[<p>在产品开发过程中，最先要考虑的就是需求，和各部门沟通的也是需求。需求是产品构建的基石，需求制定偏了，整个产品方向也就会偏离预期。</p><p>需求是什么？可以总结为几类？如何收集、筛选、实现需求。</p><p>先放上框架图，本文目的是初探需求。</p><img src="/2018/04/19/175651/01_Structure.png"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>需求是指人在某个场景下的心理活动。（用户 - 场景  - 心理）</p><p>小明，饿了，想要吃饭。这就是需求。</p><p>所以说，需求是来源于用户的，出发点是要解决用户遇到的问题。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>优先级：</p><ul><li>必要需求：为直接解决问题，必须要做的事。</li><li>次要需求：做了会提升用户满意度，不做也不影响。</li></ul><p>小明很饿，你给了他一碗面，他能饱腹；如果给他牛肉面，他能心满意足（碰巧他很喜欢吃牛肉）。</p><p>频次：</p><ul><li>高频需求：日常生活中，频繁经历的场景。</li><li>低频需求：日常生活中，发生次数较低的场景。</li></ul><p>听音频，随时随地，这就是高频需求；充话费，一月一两次，这是低频需求。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>美国心理学家马斯洛，在上个世纪提出了<em>需求层次理论</em>，把需求分为5层，呈金字塔形状。</p><ol><li>生理需求：衣食住行，性冲动。</li><li>安全需求：人身、财产，所有权。</li><li>社交需求：亲情、友情、爱情。</li><li>尊重需求：自信、自尊、受人尊敬。</li><li>自我实现：道德、理想、愿景、成就。</li></ol><p>这个分层是说人对这些需求的依赖性，生理需求是最基本的。分层并不代表社会各阶层，任何阶层都可以有各层需求。所有的需求都可以归为这里某一层。</p><h1 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h1><ul><li>问卷调查：向潜在目标用户，发放问卷进行数据采集。（问卷调查设计，是个技术活，值得花时间学习）</li><li>热爱生活：观察环境，你会发现走过无数次的路，其实你并不熟悉。观察人们行为，从生活中发现灵感。</li><li>模拟用户：分析用户行为，代入用户角色，去体验产品，发现问题。</li><li>用户反馈：如果收到用户反馈，哪怕是自动回复下感谢，您也吱一声啊，用户才继续忍受你的bug，给你反馈。</li><li>用户访谈：和用户交流，重视用户意见，让用户有种参与感，用户和产品的联系增加，甚至自发宣传。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>深入挖掘：要认真分析从用户处收集的需求，不要只看到表面现象，深入分析用户真正的需求。</li><li>核心需求：给需求排序，按照28法则，把时间主要花在核心需求上，就能解决80%的问题。</li><li>老板需求：在创业公司，老板会时不时提出加点需求，这时需要沟通、分析老板的需求是否是表层的，然后分析给出真实需求。有些PM直接把老板需求加入需求实现里面，自己成了一个传声筒而已。</li><li>跟进需求：在制定需求之后，需要跟进需求实现的每一环，防止因理解偏差而导致结果偏离。</li></ul>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 需求 </tag>
            
            <tag> 马斯洛 </tag>
            
            <tag> 需求层次 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何打造流行  - 《引爆点》</title>
      <link href="/2018/04/15/102022/"/>
      <url>/2018/04/15/102022/</url>
      <content type="html"><![CDATA[<p>2011年之前，两个朋友网上聊天前，都是A先发送两个字 - “在吗”，有时A还喜欢加个问号”？”，B也要回复“嗯/在/在的”这几个备选词，然后开始瞎扯。大家仿佛都遵从了TCP协议一样。</p><p>这一天，你在某软件上收到一条语音，打破了整个世界的平静。楼道里、教室里、大街上，对着手机自言自语的人开始多了起来，声音此起彼伏。打望了一圈，人们看上去好像和平时一样，只是惊讶姿势如此统一，手机在手上，手在嘴边。聊天不再TCP式，假设对方永久在线，直接切入主题。微信就这样入侵了人们的世界，个个不能自已，上瘾一样。</p><p>无人问津到炙手可热，有时可能只是中间差那么一点，引爆点。</p><p>流行的特征：</p><ul><li>传染性：像流感一样，无法抗拒。</li><li>蝴蝶效应：细节可能导致失败，或者成功。</li><li>爆发式：一夜之间，家喻户晓、洛阳纸贵。</li></ul><p><em>《引爆点》- 马尔科姆·格拉德威尔</em></p><img src="/2018/04/15/102022/01_Structure.png"><h1 id="三个法则"><a href="#三个法则" class="headerlink" title="三个法则"></a>三个法则</h1><h2 id="个别人物法则"><a href="#个别人物法则" class="headerlink" title="个别人物法则"></a>个别人物法则</h2><h3 id="联系员"><a href="#联系员" class="headerlink" title="联系员"></a>联系员</h3><p>有个关于人与人之间关系的理论，叫做六度人脉理论（Six Degrees of Separation），也叫六步分离法则。它指的事地球上所有人都可以通过六层熟人关系和其他人联系起来。比如说你可以通过你最有影响力的朋友（政府官员、红人、高管），再通过他的人脉，总共不超过6次传递，就可以把你的笑话讲给特朗普听。</p><p>这里谈到的你最有影响力的朋友，就是属于联系员，这类人可以把消息最快地传播出去。如现在的网红，都是特定领域的联系员</p><h3 id="内行"><a href="#内行" class="headerlink" title="内行"></a>内行</h3><p>这类人一般在他工作的行业，或者爱好的领域，投入了足够多的时间，去尝试新事物，去研究，乐于分享。在他的圈子都很受欢迎，说话有分量。</p><p>所以我们倾向于向吃货朋友询问附近的美食，向美剧控朋友寻求资源，请程序员朋友修电脑（别打我）。</p><h3 id="推销员"><a href="#推销员" class="headerlink" title="推销员"></a>推销员</h3><p>这类人喜欢与人打交道，精力充沛，能够看透客户的心理，更容易说服别人。可以把死的说成活的，你还配合地连连点头称是。</p><h3 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h3><p>联系员靠广撒网多捞鱼，比如推荐附近一家饭店给10个朋友，可能就有5个会去；内行靠权威性，比如给5个朋友推荐餐馆，可能这5个人都会去；推销员靠心理学 + 嘴皮子，知道你喜欢这口味，给个优惠券，你就屁颠屁颠地跑去这家餐馆了。</p><h2 id="附着力因素法则"><a href="#附着力因素法则" class="headerlink" title="附着力因素法则"></a>附着力因素法则</h2><h3 id="打磨产品"><a href="#打磨产品" class="headerlink" title="打磨产品"></a>打磨产品</h3><p>一款产品，用尽手段，即使拉到了用户，短期内实现了增长。但如果产品本身不够好，没有用户黏性，具有欺骗性质的。要不了多久，还是会趋近于其本身所应处的位置。</p><h3 id="扫除障碍"><a href="#扫除障碍" class="headerlink" title="扫除障碍"></a>扫除障碍</h3><p>为什么国外大公司进入中国，大都会水土不服？或许他们认为Too good for us，不屑针对本地化进行定制；或许不懂国情和文化。针对目标用户设计，倾听用户意见，这些措施能够减少用户的负担，使得用户易于使用产品。</p><h2 id="环境威力法则"><a href="#环境威力法则" class="headerlink" title="环境威力法则"></a>环境威力法则</h2><h3 id="破窗理论"><a href="#破窗理论" class="headerlink" title="破窗理论"></a>破窗理论</h3><p>如果一栋房屋有几扇窗户被打破了，没有修理，慢慢地有会有更多窗户被打破。类似的有，音乐节上，嘈杂的人群，一个人开始没有带走垃圾，不久到处都是垃圾；如某xxBeta新闻网站，一个人开始评论脏话，无脑喷子，管理员不清理，慢慢的整个网站评论下都是喷子。</p><p>尤其产品初期，通过紧盯反馈，评论，及时解决用户问题，疏导用户情绪；企业遇到公关危机，及时PR，不然越来越多吃瓜群众也开始跟着抨击。</p><h3 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h3><p>人们总爱犯的一种错误是，高估性格因素，低估具体情形和环境因素。</p><p>近朱者赤近墨者黑。要理解环境的重要性，营造良好的环境、基调、氛围，针对具体情形迅速拿出可行的方案。</p><h3 id="群体力量"><a href="#群体力量" class="headerlink" title="群体力量"></a>群体力量</h3><p>任何新兴意识形态的传播都要借助于群体力量。为了长期发展，增加用户黏性，必须建立社区或组织，这样人们可以交流，互相影响，提高忠诚度，产生1 + 1 &gt; 2的效果。</p><h1 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h1><h3 id="单点突破"><a href="#单点突破" class="headerlink" title="单点突破"></a>单点突破</h3><p>尤其是企业，产品初期，可用的资源有限，无法覆盖全面，把有限的资源集中用到关键方面。也就是现在常说的单点突破</p><h3 id="传真机效应"><a href="#传真机效应" class="headerlink" title="传真机效应"></a>传真机效应</h3><p>也叫充裕定律，加入网络的个体越多，网络的价值越高。</p><p>第一台传真机零售价2000美元，如果世界仅此一台，它是毫无价值的。第二台传真机，使得第一台有了价值。第三台传真机使得彼此更有价值。比如我们更多是用微信，而很少用FB，或其他私密社交，因为我们的熟人都在这里，别的软件就没那么多价值。</p><h3 id="内行陷阱"><a href="#内行陷阱" class="headerlink" title="内行陷阱"></a>内行陷阱</h3><p>这不是个贬义词，是说如何找到内行人士。</p><p>做产品，要留下反馈渠道，只有内行才会花费时间去反馈，换做一般人，用着不合适直接不用，根本不会考虑告诉你哪里有问题。因此反馈渠道不能太深，而且收到反馈后，应予以回应，至少一条自动回复的感谢消息，也会鼓励内行人士继续使用并反馈。</p>]]></content>
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 产品 </tag>
            
            <tag> 引爆点 </tag>
            
            <tag> 传播 </tag>
            
            <tag> 商业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程的介绍与演示</title>
      <link href="/2018/04/13/210624/"/>
      <url>/2018/04/13/210624/</url>
      <content type="html"><![CDATA[<p>本篇文章会简单介绍线程的概念，以及如何区分。接着开始讲解iOS开发中提到的4种方式，不要紧张，最常用的就2种。最后稍微带过下线程安全方面的知识。</p><p>先放出本次内容的框架图，以便有条理的阅读和掌握。</p><div align="center"><br><br><img src="/2018/04/13/210624/01_Thread.png"><br><br></div><p><em>环境： Swift 4.1  Xcode 9.3</em></p><p><em>可下载工程项目，进行把玩，更直观地了解。</em> <a href="https://github.com/ronansparks/ThreadForiOS-Demo" target="_blank" rel="noopener">Github</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>程序/App：</strong>只是存储数据和文件的文件夹。如一辆Tesla。</p><p><strong>进程：</strong>启动App，才开始有了进程。把车启动了，才能跑起来。</p><p><strong>线程：</strong>一个进程里可以有很多线程，把资源和任务交给它们去执行。车轮跑起来，开冷气，显示屏，都是交给很多的零件负责执行。</p><h2 id="细说线程"><a href="#细说线程" class="headerlink" title="细说线程"></a>细说线程</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>在iOS里，处理UI的线程就是主线程，在App启动时由系统自动创建。不要把耗时的操作放在主线程里，会造成页面的卡顿、不响应、崩溃。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>理论上同一时刻，一个CPU只能处理一条线程。但是线程间切换极快，你感觉在同时听歌、聊微信、下载歌曲。使用多线程就是为了提高效率，最大化利用资源，节省时间。</p><h3 id="线程周期"><a href="#线程周期" class="headerlink" title="线程周期"></a>线程周期</h3><p>线程生命周期，如下图所示</p><div align="center"><br><br><img src="/2018/04/13/210624/02_Thread_LifeCycle.jpg"><br><br></div><p>新建：实例化线程对象。</p><p>待运行：线程实例对象调用start方法，被加入可调度线程池，等待CPU调度。</p><p>运行中：CPU调度该线程实例对象。在完成任务前，CPU可能跑去调度别的线程，使该线程在<strong>待运行</strong>和<strong>运行中</strong>状态间切换。</p><p>阻塞：阻塞该线程执行任何操作。可以手动设置休眠、设置锁、移除可调度线程池。</p><p>结束：完成任务，正常结束周期；未完成任务前，被终止。</p><h1 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h1><h2 id="四种方案"><a href="#四种方案" class="headerlink" title="四种方案"></a>四种方案</h2><h3 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h3><p><strong>POSIX</strong>（POSIX threads），一套可在Unix/Linux/Mac等系统通用的多线程API。要手动管理生命周期，太繁琐。</p><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>由Apple提供的，更面向对象，易操作的线程对象。也需要手动管理生命周期。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>全称为Grand Centeral Dispatch，由Apple推出，用以替代NSThread，更高效地利用多核。自动管理生命周期。</p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>Apple把GCD封装了一层，操作更简便，更符合面向对象。自动管理生命周期。</p><p>我们几乎不怎么使用Pthread，很少使用NSThread。常用的就是GCD和NSOperation</p><h2 id="细说GCD"><a href="#细说GCD" class="headerlink" title="细说GCD"></a>细说GCD</h2><p>要细说GCD，先引入几个概念。</p><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p>同步（sync）和异步（async）指的是能否开启新线程。</p><p>同步：多个任务情况下（如A、B、C），任务A执行结束，才执行B，B执行结束，才执行C。仅一个线程。</p><p>异步：也就是多线程的意思。开启新线程，多个任务可以同时执行。</p><pre><code>//在全局并发队列，同步执行 - 单线程DispatchQueue.global().sync {}//在全局并发队列，异步执行 - 多线程DispatchQueue.global().async {}</code></pre><h3 id="串行、并发"><a href="#串行、并发" class="headerlink" title="串行、并发"></a>串行、并发</h3><p>串行队列（Serial）和并发队列（Concurrent）指的是任务的执行方式。</p><p>串行队列：多个线程时，各个线程按顺序执行，执行完一个线程，才能进入下一个线程。</p><p>并发队列：多个线程可以同时执行。</p><p>手动创建队列的方法</p><pre><code class="swift">//串行队列let serialQueue = DispatchQueue(label: &quot;com.ronansparks.serial&quot;)//并发队列let concurrentQueue = DispatchQueue(label: &quot;com.ronansparks.concurrent&quot;, attributes: .concurrent)</code></pre><p>获取GCD全局队列的方法</p><pre><code class="swift">//获取GCD全局并发队列，优先级为默认级别DispatchQueue.global().async {    //耗时任务放这里执行    //获取GCD主队列    DispatchQueue.main.async {    //回主线程，操作UI    }}</code></pre><ul><li>同步不会开启新线程，只能按顺序执行；</li><li>串行队列，规定只能顺序执行；（主队列也是串行）</li><li>主队列使用同步，会发生死锁，导致程序崩溃。</li><li>只有并发队列使用异步，才能高效利用资源。开启新线程，同时执行多个任务。</li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>在前面获取GCD全局队列的方法里，就是异步线程中耗时操作结束，回到主线程操作UI</p><p>在多个异步并发队列间，插入栅栏，在栅栏位置之后的异步队列需要等前面的所有任务执行完，才开始执行</p><pre><code class="swift">  concurrentQueue.async(flags: .barrier) {      //我是一个路障，后面的乖乖等着前面的吧  }</code></pre><p>延时执行</p><pre><code class="swift">  DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + 3) {      //3s 后要执行的任务  }</code></pre><p>队列组。把多线程都丢到一个组里，坐等所有都执行完之后的通知。</p><h2 id="细说NSOperation"><a href="#细说NSOperation" class="headerlink" title="细说NSOperation"></a>细说NSOperation</h2><p>NSOperation是对GCD的封装，需要配合NSOperationQueue才能实现多线程。只需要三步</p><ol><li>创建任务（NSOperation）</li><li>创建队列（NSOperationQueue）</li><li>把任务添加到队列</li></ol><p>NSOperation是个抽象类，我们使用它的子类NSBlockOperation（用Objective-C还有子类NSInvocationOperation，因为不是类型安全，所以在Swift里被禁用了），或者自定义子类。</p><ul><li>不添加到队列，需要手动调用start方法，默认在主线程执行。</li><li>Operation添加到队列后，自动执行。</li><li>实例可以通过添加执行代码块的方式，实现主线程。<strong>addExecutionBlock { code }</strong></li></ul><p>NSOperationQueue有主队列、和其他队列（串行、并发）。</p><ul><li>可以不需要单独创建Operation，通过队列代码块实现异步。</li><li>同GCD，在耗时操作执行后，切回主线程操作UI。通过<strong>OperationQueue.main</strong>访问主线程队列，把UI操作加入到该队列</li><li>可以设置最大并发数。设置为1，即顺序执行。</li><li>可以取消、暂停某个操作或整个队列里的操作。</li><li>可以设置依赖，即B必须在A完成之后才能执行。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多个线程访问一个资源的时候，容易导致数据错乱、数据安全问题。</p><p>互斥锁（同步锁）：第一个线程访问的时候，加个锁，表示它在使用；后来的都无法访问，进入休眠。</p><p>自旋锁：当新线程访问时，发现对象已被锁定，它会一直等待，不停尝试访问，耗性能。</p>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS个人开发者账号申请</title>
      <link href="/2018/04/11/081157/"/>
      <url>/2018/04/11/081157/</url>
      <content type="html"><![CDATA[<p>今天来手把手讲解一下，申请iOS个人开发者账号的流程。一个从旁观者，到参与者的转变。</p><p>有两个必备条件：</p><ul><li>一个Apple ID</li><li>一张Visa / Master的国际信用卡</li></ul><p>对于Apple ID，如果你有一部iPhone/iPad/Macbook，那也就有了账号。没有呢，也没有关系，先去这里 <a href="https://appleid.apple.com/account?localang=en_US&amp;appId=632&amp;returnURL=https%3A%2F%2Fidmsa.apple.com%2FIDMSWebAuth%2Flogin.html%3Flanguage%3DUS-EN%26rv%3D1%26path%3D%252Faccount%252F%26Env%3DUAT%26appIdKey%3D891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757#!&amp;page=create" target="_blank" rel="noopener">注册Apple ID</a> 。</p><p>对于国际信用卡，没有的可以去银行申请（推荐招行），或者跟朋友借。</p><p>开始进入正题：</p><ol><li><p>现在打开 <a href="https://developer.apple.com/programs/cn/" target="_blank" rel="noopener">Apple 开发者</a> 首页，这里可以也找到开发文档、设计指南。（无论是设计师，还是开发者，都应该看下苹果的人机交互指南。）</p></li><li><p>点击右上方的<strong>注册</strong>按钮，跳转页面。</p></li><li><p>跳转后，点击页面底部<strong>开始注册</strong>按钮，跳转页面。</p></li><li><p>输入Apple ID账号和密码，跳转页面。</p></li><li><p>检查上方<strong>Name</strong>后面的拼音是不是真实姓名（如张三，应显示 SAN ZHANG，大小写都行），正确的话进入下一步。（个人开发者，名称必须和身份证上一致！不然付款成功后会要求上传身份证，不一致的话还需要修改并再次上传身份证。如果需要修改，去 <a href="https://appleid.apple.com/#!&amp;page=signin" target="_blank" rel="noopener">Apple ID登录</a> ，在账户区域的右边有个<strong>编辑</strong>，点击进行修改。）</p></li><li><p>选择开发者账号类型，这里选择<strong>Individual / Sole Proprietor / Single Person Business</strong>，即个人开发者类型，点击<strong>Continue</strong>按钮，跳转页面。</p></li><li><p>填写个人信息（如下图），完成后点击<strong>Continue</strong>按钮，跳转页面。</p><img src="/2018/04/11/081157/01_Info.jpg"></li><li><p>核对信息无误后，点击<strong>Continue</strong>，跳转页面。</p></li><li><p>确认订单，价格：688，期限：1年。点击<strong>Purchase</strong>进行购买。</p></li><li><p>输入信用卡信息，确认账单地址，这里没什么好说的，提示缺啥填啥。直接下一步、下一步、立即下订单。立刻会收到付款成功邮件，就表示成功了。十分钟左右还会收到电子收据邮件。</p></li><li><p>坐等苹果通知。（一般在24h 内通过，可到开发者中心查询状态。如24小时后仍处于<strong>Pending</strong>状态，直接给苹果开发者中心打电话 <strong>4006 701 855</strong> ）</p><p>​</p></li></ol>]]></content>
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 开发者账号 </tag>
            
            <tag> App Store </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
