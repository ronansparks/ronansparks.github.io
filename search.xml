<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>23种设计模式的Swift实现</title>
      <link href="/2018/04/21/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/21/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在介绍设计模式之前，先声明几点，以免大家误入歧途。</p><p>对于设计模式的作用，一直很有争议。有人奉为圭臬，有人嗤之以鼻，他们的认知都错了吗？不是的，他们都受了“知识的诅咒”。</p><p>“知识的诅咒”是说，在你学会一个方法前，觉得好像有点难；而在你学会之后，很难想象不会这个方法是种什么样的体验。比如你学会了修电脑之后，觉得挺简单的，就纳闷“怎么会有人不懂修电脑？”（5分钟就搞定，那我就不留下来过夜了…）。</p><p>新手刚学习了设计模式，但是还没有完全理解，急于应用在代码中，就会出现生搬硬套，过度设计的状况。</p><p>而嗤之以鼻的人觉得没有自己学习设计模式，也写过了很多“单例模式”、“观察者模式”，这是属于一种探索的模式，以实践代替理论，这可能导致疏忽，写来写去也就会那几种模式，遇到问题时，需要花费数倍的时间来探索。</p><p>而学了设计模式的人，并知道设计模式的出现是为了解决什么问题，他们并不会随时想着使用设计模式，而是在需要的时候，灵活应用。</p><h2 id="理性看待"><a href="#理性看待" class="headerlink" title="理性看待"></a>理性看待</h2><p>设计模式，只是一种对经验的总结。因为这些解决问题的方法，被反复使用，是开发者试错、验证总结出来的。所以对它们进行整理分类，给更多的人看到，避免采坑，避免重复造轮子（每个人都根据经验自己总结一遍）。</p><p>设计模式的目的，为了代码的可重用性、可靠性，便于与其他开发者的沟通。</p><img src="/2018/04/21/23种设计模式的Swift实现/01_23种设计模式.png"><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><p>这些模式关注在创建对象时，对内部创建逻辑的隐藏方式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例，并可在全局访问。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="访问器模式"><a href="#访问器模式" class="headerlink" title="访问器模式"></a>访问器模式</h2><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>产品需求 - 从理解到实施</title>
      <link href="/2018/04/19/%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82-%E4%BB%8E%E7%90%86%E8%A7%A3%E5%88%B0%E5%AE%9E%E6%96%BD/"/>
      <url>/2018/04/19/%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82-%E4%BB%8E%E7%90%86%E8%A7%A3%E5%88%B0%E5%AE%9E%E6%96%BD/</url>
      <content type="html"><![CDATA[<p>在产品开发过程中，最先要考虑的就是需求，和各部门沟通的也是需求。需求是产品构建的基石，需求制定偏了，整个产品方向也就会偏离预期。</p><p>需求是什么？可以总结为几类？如何收集、筛选、实现需求。</p><p>先放上框架图，本文目的是初探需求。</p><img src="/2018/04/19/产品需求-从理解到实施/01_Structure.png"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>需求是指人在某个场景下的心理活动。（用户 - 场景  - 心理）</p><p>小明，饿了，想要吃饭。这就是需求。</p><p>所以说，需求是来源于用户的，出发点是要解决用户遇到的问题。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>优先级：</p><ul><li>必要需求：为直接解决问题，必须要做的事。</li><li>次要需求：做了会提升用户满意度，不做也不影响。</li></ul><p>小明很饿，你给了他一碗面，他能饱腹；如果给他牛肉面，他能心满意足（碰巧他很喜欢吃牛肉）。</p><p>频次：</p><ul><li>高频需求：日常生活中，频繁经历的场景。</li><li>低频需求：日常生活中，发生次数较低的场景。</li></ul><p>听音频，随时随地，这就是高频需求；充话费，一月一两次，这是低频需求。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>美国心理学家马斯洛，在上个世纪提出了<em>需求层次理论</em>，把需求分为5层，呈金字塔形状。</p><ol><li>生理需求：衣食住行，性冲动。</li><li>安全需求：人身、财产，所有权。</li><li>社交需求：亲情、友情、爱情。</li><li>尊重需求：自信、自尊、受人尊敬。</li><li>自我实现：道德、理想、愿景、成就。</li></ol><p>这个分层是说人对这些需求的依赖性，生理需求是最基本的。分层并不代表社会各阶层，任何阶层都可以有各层需求。所有的需求都可以归为这里某一层。</p><h1 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h1><ul><li>问卷调查：向潜在目标用户，发放问卷进行数据采集。（问卷调查设计，是个技术活，值得花时间学习）</li><li>热爱生活：观察环境，你会发现走过无数次的路，其实你并不熟悉。观察人们行为，从生活中发现灵感。</li><li>模拟用户：分析用户行为，代入用户角色，去体验产品，发现问题。</li><li>用户反馈：如果收到用户反馈，哪怕是自动回复下感谢，您也吱一声啊，用户才继续忍受你的bug，给你反馈。</li><li>用户访谈：和用户交流，重视用户意见，让用户有种参与感，用户和产品的联系增加，甚至自发宣传。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>深入挖掘：要认真分析从用户处收集的需求，不要只看到表面现象，深入分析用户真正的需求。</li><li>核心需求：给需求排序，按照28法则，把时间主要花在核心需求上，就能解决80%的问题。</li><li>老板需求：在创业公司，老板会时不时提出加点需求，这时需要沟通、分析老板的需求是否是表层的，然后分析给出真实需求。有些PM直接把老板需求加入需求实现里面，自己成了一个传声筒而已。</li><li>跟进需求：在制定需求之后，需要跟进需求实现的每一环，防止因理解偏差而导致结果偏离。</li></ul>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需求 </tag>
            
            <tag> 马斯洛 </tag>
            
            <tag> 需求层次 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何打造流行 - 《引爆点》</title>
      <link href="/2018/04/15/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E6%B5%81%E8%A1%8C-%E3%80%8A%E5%BC%95%E7%88%86%E7%82%B9%E3%80%8B/"/>
      <url>/2018/04/15/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E6%B5%81%E8%A1%8C-%E3%80%8A%E5%BC%95%E7%88%86%E7%82%B9%E3%80%8B/</url>
      <content type="html"><![CDATA[<p>2011年之前，两个朋友网上聊天前，都是A先发送两个字 - “在吗”，有时A还喜欢加个问号”？”，B也要回复“嗯/在/在的”这几个备选词，然后开始瞎扯。大家仿佛都遵从了TCP协议一样。</p><p>这一天，你在某软件上收到一条语音，打破了整个世界的平静。楼道里、教室里、大街上，对着手机自言自语的人开始多了起来，声音此起彼伏。打望了一圈，人们看上去好像和平时一样，只是惊讶姿势如此统一，手机在手上，手在嘴边。聊天不再TCP式，假设对方永久在线，直接切入主题。微信就这样入侵了人们的世界，个个不能自已，上瘾一样。</p><p>无人问津到炙手可热，有时可能只是中间差那么一点，引爆点。</p><p>流行的特征：</p><ul><li>传染性：像流感一样，无法抗拒。</li><li>蝴蝶效应：细节可能导致失败，或者成功。</li><li>爆发式：一夜之间，家喻户晓、洛阳纸贵。</li></ul><img src="/2018/04/15/如何打造流行-《引爆点》/01_Structure.png"><h1 id="三个法则"><a href="#三个法则" class="headerlink" title="三个法则"></a>三个法则</h1><h2 id="个别人物法则"><a href="#个别人物法则" class="headerlink" title="个别人物法则"></a>个别人物法则</h2><h3 id="联系员"><a href="#联系员" class="headerlink" title="联系员"></a>联系员</h3><p>有个关于人与人之间关系的理论，叫做六度人脉理论（Six Degrees of Separation），也叫六步分离法则。它指的事地球上所有人都可以通过六层熟人关系和其他人联系起来。比如说你可以通过你最有影响力的朋友（政府官员、红人、高管），再通过他的人脉，总共不超过6次传递，就可以把你的笑话讲给特朗普听。</p><p>这里谈到的你最有影响力的朋友，就是属于联系员，这类人可以把消息最快地传播出去。如现在的网红，都是特定领域的联系员</p><h3 id="内行"><a href="#内行" class="headerlink" title="内行"></a>内行</h3><p>这类人一般在他工作的行业，或者爱好的领域，投入了足够多的时间，去尝试新事物，去研究，乐于分享。在他的圈子都很受欢迎，说话有分量。</p><p>所以我们倾向于向吃货朋友询问附近的美食，向美剧控朋友寻求资源，请程序员朋友修电脑（别打我）。</p><h3 id="推销员"><a href="#推销员" class="headerlink" title="推销员"></a>推销员</h3><p>这类人喜欢与人打交道，精力充沛，能够看透客户的心理，更容易说服别人。可以把死的说成活的，你还配合地连连点头称是。</p><h3 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h3><p>联系员靠广撒网多捞鱼，比如推荐附近一家饭店给10个朋友，可能就有5个会去；内行靠权威性，比如给5个朋友推荐餐馆，可能这5个人都会去；推销员靠心理学 + 嘴皮子，知道你喜欢这口味，给个优惠券，你就屁颠屁颠地跑去这家餐馆了。</p><h2 id="附着力因素法则"><a href="#附着力因素法则" class="headerlink" title="附着力因素法则"></a>附着力因素法则</h2><h3 id="打磨产品"><a href="#打磨产品" class="headerlink" title="打磨产品"></a>打磨产品</h3><p>一款产品，用尽手段，即使拉到了用户，短期内实现了增长。但如果产品本身不够好，没有用户黏性，具有欺骗性质的。要不了多久，还是会趋近于其本身所应处的位置。</p><h3 id="扫除障碍"><a href="#扫除障碍" class="headerlink" title="扫除障碍"></a>扫除障碍</h3><p>为什么国外大公司进入中国，大都会水土不服？或许他们认为Too good for us，不屑针对本地化进行定制；或许不懂国情和文化。针对目标用户设计，倾听用户意见，这些措施能够减少用户的负担，使得用户易于使用产品。</p><h2 id="环境威力法则"><a href="#环境威力法则" class="headerlink" title="环境威力法则"></a>环境威力法则</h2><h3 id="破窗理论"><a href="#破窗理论" class="headerlink" title="破窗理论"></a>破窗理论</h3><p>如果一栋房屋有几扇窗户被打破了，没有修理，慢慢地有会有更多窗户被打破。类似的有，音乐节上，嘈杂的人群，一个人开始没有带走垃圾，不久到处都是垃圾；如某xxBeta新闻网站，一个人开始评论脏话，无脑喷子，管理员不清理，慢慢的整个网站评论下都是喷子。</p><p>尤其产品初期，通过紧盯反馈，评论，及时解决用户问题，疏导用户情绪；企业遇到公关危机，及时PR，不然越来越多吃瓜群众也开始跟着抨击。</p><h3 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h3><p>人们总爱犯的一种错误是，高估性格因素，低估具体情形和环境因素。</p><p>近朱者赤近墨者黑。要理解环境的重要性，营造良好的环境、基调、氛围，针对具体情形迅速拿出可行的方案。</p><h3 id="群体力量"><a href="#群体力量" class="headerlink" title="群体力量"></a>群体力量</h3><p>任何新兴意识形态的传播都要借助于群体力量。为了长期发展，增加用户黏性，必须建立社区或组织，这样人们可以交流，互相影响，提高忠诚度，产生1 + 1 &gt; 2的效果。</p><h1 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h1><h3 id="单点突破"><a href="#单点突破" class="headerlink" title="单点突破"></a>单点突破</h3><p>尤其是企业，产品初期，可用的资源有限，无法覆盖全面，把有限的资源集中用到关键方面。也就是现在常说的单点突破</p><h3 id="传真机效应"><a href="#传真机效应" class="headerlink" title="传真机效应"></a>传真机效应</h3><p>也叫充裕定律，加入网络的个体越多，网络的价值越高。</p><p>第一台传真机零售价2000美元，如果世界仅此一台，它是毫无价值的。第二台传真机，使得第一台有了价值。第三台传真机使得彼此更有价值。比如我们更多是用微信，而很少用FB，或其他私密社交，因为我们的熟人都在这里，别的软件就没那么多价值。</p><h3 id="内行陷阱"><a href="#内行陷阱" class="headerlink" title="内行陷阱"></a>内行陷阱</h3><p>这不是个贬义词，是说如何找到内行人士。</p><p>做产品，要留下反馈渠道，只有内行才会花费时间去反馈，换做一般人，用着不合适直接不用，根本不会考虑告诉你哪里有问题。因此反馈渠道不能太深，而且收到反馈后，应予以回应，至少一条自动回复的感谢消息，也会鼓励内行人士继续使用并反馈。</p>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引爆点 </tag>
            
            <tag> 传播 </tag>
            
            <tag> 心理学 </tag>
            
            <tag> 产品 </tag>
            
            <tag> 商业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程的介绍与演示</title>
      <link href="/2018/04/13/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%BC%94%E7%A4%BA/"/>
      <url>/2018/04/13/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%BC%94%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>本篇文章会简单介绍线程的概念，以及如何区分。接着开始讲解iOS开发中提到的4种方式，不要紧张，最常用的就2种。最后稍微带过下线程安全方面的知识。</p><p>先放出本次内容的框架图，以便有条理的阅读和掌握。</p><div align="center"><br><br><img src="/2018/04/13/iOS多线程的介绍与演示/01_Thread.png"><br><br></div><p><em>环境： Swift 4.1  Xcode 9.3</em></p><p><em>可下载工程项目，进行把玩，更直观地了解。</em> <a href="https://github.com/ronansparks/ThreadForiOS-Demo" target="_blank" rel="noopener">Github</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>程序/App：</strong>只是存储数据和文件的文件夹。如一辆Tesla。</p><p><strong>进程：</strong>启动App，才开始有了进程。把车启动了，才能跑起来。</p><p><strong>线程：</strong>一个进程里可以有很多线程，把资源和任务交给它们去执行。车轮跑起来，开冷气，显示屏，都是交给很多的零件负责执行。</p><h2 id="细说线程"><a href="#细说线程" class="headerlink" title="细说线程"></a>细说线程</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>在iOS里，处理UI的线程就是主线程，在App启动时由系统自动创建。不要把耗时的操作放在主线程里，会造成页面的卡顿、不响应、崩溃。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>理论上同一时刻，一个CPU只能处理一条线程。但是线程间切换极快，你感觉在同时听歌、聊微信、下载歌曲。使用多线程就是为了提高效率，最大化利用资源，节省时间。</p><h3 id="线程周期"><a href="#线程周期" class="headerlink" title="线程周期"></a>线程周期</h3><p>线程生命周期，如下图所示</p><div align="center"><br><br><img src="/2018/04/13/iOS多线程的介绍与演示/02_Thread_LifeCycle.jpg"><br><br></div><p>新建：实例化线程对象。</p><p>待运行：线程实例对象调用start方法，被加入可调度线程池，等待CPU调度。</p><p>运行中：CPU调度该线程实例对象。在完成任务前，CPU可能跑去调度别的线程，使该线程在<strong>待运行</strong>和<strong>运行中</strong>状态间切换。</p><p>阻塞：阻塞该线程执行任何操作。可以手动设置休眠、设置锁、移除可调度线程池。</p><p>结束：完成任务，正常结束周期；未完成任务前，被终止。</p><h1 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h1><h2 id="四种方案"><a href="#四种方案" class="headerlink" title="四种方案"></a>四种方案</h2><h3 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h3><p><strong>POSIX</strong>（POSIX threads），一套可在Unix/Linux/Mac等系统通用的多线程API。要手动管理生命周期，太繁琐。</p><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>由Apple提供的，更面向对象，易操作的线程对象。也需要手动管理生命周期。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>全称为Grand Centeral Dispatch，由Apple推出，用以替代NSThread，更高效地利用多核。自动管理生命周期。</p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>Apple把GCD封装了一层，操作更简便，更符合面向对象。自动管理生命周期。</p><p>我们几乎不怎么使用Pthread，很少使用NSThread。常用的就是GCD和NSOperation</p><h2 id="细说GCD"><a href="#细说GCD" class="headerlink" title="细说GCD"></a>细说GCD</h2><p>要细说GCD，先引入几个概念。</p><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p>同步（sync）和异步（async）指的是能否开启新线程。</p><p>同步：多个任务情况下（如A、B、C），任务A执行结束，才执行B，B执行结束，才执行C。仅一个线程。</p><p>异步：也就是多线程的意思。开启新线程，多个任务可以同时执行。</p><pre><code>//在全局并发队列，同步执行 - 单线程DispatchQueue.global().sync {}//在全局并发队列，异步执行 - 多线程DispatchQueue.global().async {}</code></pre><h3 id="串行、并发"><a href="#串行、并发" class="headerlink" title="串行、并发"></a>串行、并发</h3><p>串行队列（Serial）和并发队列（Concurrent）指的是任务的执行方式。</p><p>串行队列：多个线程时，各个线程按顺序执行，执行完一个线程，才能进入下一个线程。</p><p>并发队列：多个线程可以同时执行。</p><p>手动创建队列的方法</p><pre><code class="swift">//串行队列let serialQueue = DispatchQueue(label: &quot;com.ronansparks.serial&quot;)//并发队列let concurrentQueue = DispatchQueue(label: &quot;com.ronansparks.concurrent&quot;, attributes: .concurrent)</code></pre><p>获取GCD全局队列的方法</p><pre><code class="swift">//获取GCD全局并发队列，优先级为默认级别DispatchQueue.global().async {    //耗时任务放这里执行    //获取GCD主队列    DispatchQueue.main.async {    //回主线程，操作UI    }}</code></pre><ul><li>同步不会开启新线程，只能按顺序执行；</li><li>串行队列，规定只能顺序执行；（主队列也是串行）</li><li>主队列使用同步，会发生死锁，导致程序崩溃。</li><li>只有并发队列使用异步，才能高效利用资源。开启新线程，同时执行多个任务。</li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>在前面获取GCD全局队列的方法里，就是异步线程中耗时操作结束，回到主线程操作UI</p><p>在多个异步并发队列间，插入栅栏，在栅栏位置之后的异步队列需要等前面的所有任务执行完，才开始执行</p><pre><code class="swift">  concurrentQueue.async(flags: .barrier) {      //我是一个路障，后面的乖乖等着前面的吧  }</code></pre><p>延时执行</p><pre><code class="swift">  DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + 3) {      //3s 后要执行的任务  }</code></pre><p>队列组。把多线程都丢到一个组里，坐等所有都执行完之后的通知。</p><h2 id="细说NSOperation"><a href="#细说NSOperation" class="headerlink" title="细说NSOperation"></a>细说NSOperation</h2><p>NSOperation是对GCD的封装，需要配合NSOperationQueue才能实现多线程。只需要三步</p><ol><li>创建任务（NSOperation）</li><li>创建队列（NSOperationQueue）</li><li>把任务添加到队列</li></ol><p>NSOperation是个抽象类，我们使用它的子类NSBlockOperation（用Objective-C还有子类NSInvocationOperation，因为不是类型安全，所以在Swift里被禁用了），或者自定义子类。</p><ul><li>不添加到队列，需要手动调用start方法，默认在主线程执行。</li><li>Operation添加到队列后，自动执行。</li><li>实例可以通过添加执行代码块的方式，实现主线程。<strong>addExecutionBlock { code }</strong></li></ul><p>NSOperationQueue有主队列、和其他队列（串行、并发）。</p><ul><li>可以不需要单独创建Operation，通过队列代码块实现异步。</li><li>同GCD，在耗时操作执行后，切回主线程操作UI。通过<strong>OperationQueue.main</strong>访问主线程队列，把UI操作加入到该队列</li><li>可以设置最大并发数。设置为1，即顺序执行。</li><li>可以取消、暂停某个操作或整个队列里的操作。</li><li>可以设置依赖，即B必须在A完成之后才能执行。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多个线程访问一个资源的时候，容易导致数据错乱、数据安全问题。</p><p>互斥锁（同步锁）：第一个线程访问的时候，加个锁，表示它在使用；后来的都无法访问，进入休眠。</p><p>自旋锁：当新线程访问时，发现对象已被锁定，它会一直等待，不停尝试访问，耗性能。</p>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS个人开发者账号申请</title>
      <link href="/2018/04/11/iOS%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7/"/>
      <url>/2018/04/11/iOS%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7/</url>
      <content type="html"><![CDATA[<p>今天来手把手讲解一下，申请iOS个人开发者账号的流程。一个从旁观者，到参与者的转变。</p><p>有两个必备条件：</p><ul><li>一个Apple ID</li><li>一张Visa / Master的国际信用卡</li></ul><p>对于Apple ID，如果你有一部iPhone/iPad/Macbook，那也就有了账号。没有呢，也没有关系，先去这里 <a href="https://appleid.apple.com/account?localang=en_US&amp;appId=632&amp;returnURL=https%3A%2F%2Fidmsa.apple.com%2FIDMSWebAuth%2Flogin.html%3Flanguage%3DUS-EN%26rv%3D1%26path%3D%252Faccount%252F%26Env%3DUAT%26appIdKey%3D891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757#!&amp;page=create" target="_blank" rel="noopener">注册Apple ID</a> 。</p><p>对于国际信用卡，没有的可以去银行申请（推荐招行），或者跟朋友借。</p><p>开始进入正题：</p><ol><li><p>现在打开 <a href="https://developer.apple.com/programs/cn/" target="_blank" rel="noopener">Apple 开发者</a> 首页，这里可以也找到开发文档、设计指南。（无论是设计师，还是开发者，都应该看下苹果的人机交互指南。）</p></li><li><p>点击右上方的<strong>注册</strong>按钮，跳转页面。</p></li><li><p>跳转后，点击页面底部<strong>开始注册</strong>按钮，跳转页面。</p></li><li><p>输入Apple ID账号和密码，跳转页面。</p></li><li><p>检查上方<strong>Name</strong>后面的拼音是不是真实姓名（如张三，应显示 SAN ZHANG，大小写都行），正确的话进入下一步。（个人开发者，名称必须和身份证上一致！不然付款成功后会要求上传身份证，不一致的话还需要修改并再次上传身份证。如果需要修改，去 <a href="https://appleid.apple.com/#!&amp;page=signin" target="_blank" rel="noopener">Apple ID登录</a> ，在账户区域的右边有个<strong>编辑</strong>，点击进行修改。）</p></li><li><p>选择开发者账号类型，这里选择<strong>Individual / Sole Proprietor / Single Person Business</strong>，即个人开发者类型，点击<strong>Continue</strong>按钮，跳转页面。</p></li><li><p>填写个人信息（如下图），完成后点击<strong>Continue</strong>按钮，跳转页面。</p><img src="/2018/04/11/iOS个人开发者账号申请/01_Info.jpg"></li><li><p>核对信息无误后，点击<strong>Continue</strong>，跳转页面。</p></li><li><p>确认订单，价格：688，期限：1年。点击<strong>Purchase</strong>进行购买。</p></li><li><p>输入信用卡信息，确认账单地址，这里没什么好说的，提示缺啥填啥。直接下一步、下一步、立即下订单。立刻会收到付款成功邮件，就表示成功了。十分钟左右还会收到电子收据邮件。</p></li><li><p>坐等苹果通知。（一般在24h 内通过，可到开发者中心查询状态。如24小时后仍处于<strong>Pending</strong>状态，直接给苹果开发者中心打电话 <strong>4006 701 855</strong> ）</p><p>​</p></li></ol>]]></content>
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发者账号 </tag>
            
            <tag> App Store </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
